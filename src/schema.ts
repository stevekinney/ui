/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/cluster-info': {
    /** @description GetClusterInfo returns information about temporal cluster */
    get: operations['GetClusterInfo'];
  };
  '/api/v1/namespaces': {
    /** @description ListNamespaces returns the information and configuration for all namespaces. */
    get: operations['ListNamespaces'];
    /**
     * @description RegisterNamespace creates a new namespace which can be used as a container for all resources.
     *
     *  A Namespace is a top level entity within Temporal, and is used as a container for resources
     *  like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
     *  isolation for all resources within the namespace. All resources belongs to exactly one
     *  namespace.
     */
    post: operations['RegisterNamespace'];
  };
  '/api/v1/namespaces/{namespace}': {
    /** @description DescribeNamespace returns the information and configuration for a registered namespace. */
    get: operations['DescribeNamespace'];
  };
  '/api/v1/namespaces/{namespace}/activities/cancel': {
    /**
     * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
     *
     *  This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
     *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *  no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCanceled'];
  };
  '/api/v1/namespaces/{namespace}/activities/cancel-by-id': {
    /**
     * @description See `RecordActivityTaskCanceled`. This version allows clients to record failures by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskCanceledById'];
  };
  '/api/v1/namespaces/{namespace}/activities/complete': {
    /**
     * @description RespondActivityTaskCompleted is called by workers when they successfully complete an activity
     *  task.
     *
     *  This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
     *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *  no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCompleted'];
  };
  '/api/v1/namespaces/{namespace}/activities/complete-by-id': {
    /**
     * @description See `RecordActivityTaskCompleted`. This version allows clients to record completions by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskCompletedById'];
  };
  '/api/v1/namespaces/{namespace}/activities/fail': {
    /**
     * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
     *
     *  This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
     *  a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
     *  longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskFailed'];
  };
  '/api/v1/namespaces/{namespace}/activities/fail-by-id': {
    /**
     * @description See `RecordActivityTaskFailed`. This version allows clients to record failures by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskFailedById'];
  };
  '/api/v1/namespaces/{namespace}/activities/heartbeat': {
    /**
     * @description RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
     *
     *  If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
     *  then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
     *  the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
     *  such situations, in that event, the SDK should request cancellation of the activity.
     */
    post: operations['RecordActivityTaskHeartbeat'];
  };
  '/api/v1/namespaces/{namespace}/activities/heartbeat-by-id': {
    /**
     * @description See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RecordActivityTaskHeartbeatById'];
  };
  '/api/v1/namespaces/{namespace}/activities/pause': {
    /**
     * @description PauseActivity pauses the execution of an activity specified by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be paused
     *
     *  Pausing an activity means:
     *  - If the activity is currently waiting for a retry or is running and subsequently fails,
     *    it will not be rescheduled until it is unpaused.
     *  - If the activity is already paused, calling this method will have no effect.
     *  - If the activity is running and finishes successfully, the activity will be completed.
     *  - If the activity is running and finishes with failure:
     *    * if there is no retry left - the activity will be completed.
     *    * if there are more retries left - the activity will be paused.
     *  For long-running activities:
     *  - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
     *  - The activity should respond to the cancellation accordingly.
     *
     *  Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['PauseActivity'];
  };
  '/api/v1/namespaces/{namespace}/activities/reset': {
    /**
     * @description ResetActivity resets the execution of an activity specified by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be reset.
     *
     *  Resetting an activity means:
     *  * number of attempts will be reset to 0.
     *  * activity timeouts will be reset.
     *  * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
     *     it will be scheduled immediately (* see 'jitter' flag),
     *
     *  Flags:
     *
     *  'jitter': the activity will be scheduled at a random time within the jitter duration.
     *  If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
     *  'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
     *  'keep_paused': if the activity is paused, it will remain paused.
     *
     *  Returns a `NotFound` error if there is no pending activity with the provided ID or type.
     */
    post: operations['ResetActivity'];
  };
  '/api/v1/namespaces/{namespace}/activities/unpause': {
    /**
     * @description UnpauseActivity unpauses the execution of an activity specified by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be unpaused.
     *
     *  If activity is not paused, this call will have no effect.
     *  If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
     *  Once the activity is unpaused, all timeout timers will be regenerated.
     *
     *  Flags:
     *  'jitter': the activity will be scheduled at a random time within the jitter duration.
     *  'reset_attempts': the number of attempts will be reset.
     *  'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
     *
     *  Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['UnpauseActivity'];
  };
  '/api/v1/namespaces/{namespace}/activities/update-options': {
    /**
     * @description UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be updated.
     */
    post: operations['UpdateActivityOptions'];
  };
  '/api/v1/namespaces/{namespace}/archived-workflows': {
    /** @description ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
    get: operations['ListArchivedWorkflowExecutions'];
  };
  '/api/v1/namespaces/{namespace}/batch-operations': {
    /** @description ListBatchOperations returns a list of batch operations */
    get: operations['ListBatchOperations'];
  };
  '/api/v1/namespaces/{namespace}/batch-operations/{jobId}': {
    /** @description DescribeBatchOperation returns the information about a batch operation */
    get: operations['DescribeBatchOperation'];
    /** @description StartBatchOperation starts a new batch operation */
    post: operations['StartBatchOperation'];
  };
  '/api/v1/namespaces/{namespace}/batch-operations/{jobId}/stop': {
    /** @description StopBatchOperation stops a batch operation */
    post: operations['StopBatchOperation'];
  };
  '/api/v1/namespaces/{namespace}/current-deployment/{deployment.series_name}': {
    /**
     * @description Sets a deployment as the current deployment for its deployment series. Can optionally update
     *  the metadata of the deployment as well.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
     */
    post: operations['SetCurrentDeployment'];
  };
  '/api/v1/namespaces/{namespace}/current-deployment/{seriesName}': {
    /**
     * @description Returns the current deployment (and its info) for a given deployment series.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
     */
    get: operations['GetCurrentDeployment'];
  };
  '/api/v1/namespaces/{namespace}/deployments': {
    /**
     * @description Lists worker deployments in the namespace. Optionally can filter based on deployment series
     *  name.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced with `ListWorkerDeployments`.
     */
    get: operations['ListDeployments'];
  };
  '/api/v1/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}': {
    /**
     * @description Describes a worker deployment.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
     */
    get: operations['DescribeDeployment'];
  };
  '/api/v1/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}/reachability': {
    /**
     * @description Returns the reachability level of a worker deployment to help users decide when it is time
     *  to decommission a deployment. Reachability level is calculated based on the deployment's
     *  `status` and existing workflows that depend on the given deployment for their execution.
     *  Calculating reachability is relatively expensive. Therefore, server might return a recently
     *  cached value. In such a case, the `last_update_time` will inform you about the actual
     *  reachability calculation time.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
     */
    get: operations['GetDeploymentReachability'];
  };
  '/api/v1/namespaces/{namespace}/schedules': {
    /** @description List all schedules in a namespace. */
    get: operations['ListSchedules'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}': {
    /** @description Returns the schedule description and current state of an existing schedule. */
    get: operations['DescribeSchedule'];
    /** @description Creates a new schedule. */
    post: operations['CreateSchedule'];
    /** @description Deletes a schedule, removing it from the system. */
    delete: operations['DeleteSchedule'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/matching-times': {
    /** @description Lists matching times within a range. */
    get: operations['ListScheduleMatchingTimes'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/patch': {
    /** @description Makes a specific change to a schedule or triggers an immediate action. */
    post: operations['PatchSchedule'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/update': {
    /** @description Changes the configuration or state of an existing schedule. */
    post: operations['UpdateSchedule'];
  };
  '/api/v1/namespaces/{namespace}/search-attributes': {
    /** @description ListSearchAttributes returns comprehensive information about search attributes. */
    get: operations['ListSearchAttributes'];
  };
  '/api/v1/namespaces/{namespace}/task-queues/{task_queue.name}': {
    /**
     * @description DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
     *    - List of pollers
     *    - Workflow Reachability status
     *    - Backlog info for Workflow and/or Activity tasks
     */
    get: operations['DescribeTaskQueue'];
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility': {
    /**
     * @description Deprecated. Use `GetWorkerVersioningRules`.
     *  Fetches the worker build id versioning sets for a task queue.
     */
    get: operations['GetWorkerBuildIdCompatibility'];
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules': {
    /**
     * @description Fetches the Build ID assignment and redirect rules for a Task Queue.
     *  WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
     */
    get: operations['GetWorkerVersioningRules'];
  };
  '/api/v1/namespaces/{namespace}/update': {
    /**
     * @description UpdateNamespace is used to update the information and configuration of a registered
     *  namespace.
     */
    post: operations['UpdateNamespace'];
  };
  '/api/v1/namespaces/{namespace}/worker-deployment-versions/{version}': {
    /**
     * @description Describes a worker deployment version.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    get: operations['DescribeWorkerDeploymentVersion'];
    /**
     * @description Used for manual deletion of Versions. User can delete a Version only when all the
     *  following conditions are met:
     *   - It is not the Current or Ramping Version of its Deployment.
     *   - It has no active pollers (none of the task queues in the Version have pollers)
     *   - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
     *     can be skipped by passing `skip-drainage=true`.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    delete: operations['DeleteWorkerDeploymentVersion'];
  };
  '/api/v1/namespaces/{namespace}/worker-deployment-versions/{version}/update-metadata': {
    /**
     * @description Updates the user-given metadata attached to a Worker Deployment Version.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    post: operations['UpdateWorkerDeploymentVersionMetadata'];
  };
  '/api/v1/namespaces/{namespace}/worker-deployments': {
    /**
     * @description Lists all Worker Deployments that are tracked in the Namespace.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    get: operations['ListWorkerDeployments'];
  };
  '/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}': {
    /**
     * @description Describes a Worker Deployment.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    get: operations['DescribeWorkerDeployment'];
    /**
     * @description Deletes records of (an old) Deployment. A deployment can only be deleted if
     *  it has no Version in it.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    delete: operations['DeleteWorkerDeployment'];
  };
  '/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version': {
    /**
     * @description Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
     *  Version if it is the Version being set as Current.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    post: operations['SetWorkerDeploymentCurrentVersion'];
  };
  '/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version': {
    /**
     * @description Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
     *  gradual ramp to unversioned workers too.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    post: operations['SetWorkerDeploymentRampingVersion'];
  };
  '/api/v1/namespaces/{namespace}/worker-task-reachability': {
    /**
     * @description Deprecated. Use `DescribeTaskQueue`.
     *
     *  Fetches task reachability to determine whether a worker may be retired.
     *  The request may specify task queues to query for or let the server fetch all task queues mapped to the given
     *  build IDs.
     *
     *  When requesting a large number of task queues or all task queues associated with the given build ids in a
     *  namespace, all task queues will be listed in the response but some of them may not contain reachability
     *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
     *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
     *  another call to get the reachability for those task queues.
     *
     *  Open source users can adjust this limit by setting the server's dynamic config value for
     *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
     */
    get: operations['GetWorkerTaskReachability'];
  };
  '/api/v1/namespaces/{namespace}/workflow-count': {
    /** @description CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
    get: operations['CountWorkflowExecutions'];
  };
  '/api/v1/namespaces/{namespace}/workflow-rules': {
    /** @description Return all namespace workflow rules */
    get: operations['ListWorkflowRules'];
    /**
     * @description Create a new workflow rule. The rules are used to control the workflow execution.
     *  The rule will be applied to all running and new workflows in the namespace.
     *  If the rule with such ID already exist this call will fail
     *  Note: the rules are part of namespace configuration and will be stored in the namespace config.
     *  Namespace config is eventually consistent.
     */
    post: operations['CreateWorkflowRule'];
  };
  '/api/v1/namespaces/{namespace}/workflow-rules/{ruleId}': {
    /**
     * @description DescribeWorkflowRule return the rule specification for existing rule id.
     *  If there is no rule with such id - NOT FOUND error will be returned.
     */
    get: operations['DescribeWorkflowRule'];
    /** @description Delete rule by rule id */
    delete: operations['DeleteWorkflowRule'];
  };
  '/api/v1/namespaces/{namespace}/workflows': {
    /** @description ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
    get: operations['ListWorkflowExecutions'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}': {
    /** @description DescribeWorkflowExecution returns information about the specified workflow execution. */
    get: operations['DescribeWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history': {
    /**
     * @description GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
     *  `NotFound` if the specified workflow execution is unknown to the service.
     */
    get: operations['GetWorkflowExecutionHistory'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history-reverse': {
    /**
     * @description GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
     *  order (starting from last event). Fails with`NotFound` if the specified workflow execution is
     *  unknown to the service.
     */
    get: operations['GetWorkflowExecutionHistoryReverse'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/query/{query.query_type}': {
    /** @description QueryWorkflow requests a query be executed for a specified workflow execution. */
    post: operations['QueryWorkflow'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/trigger-rule': {
    /**
     * @description TriggerWorkflowRule allows to:
     *   * trigger existing rule for a specific workflow execution;
     *   * trigger rule for a specific workflow execution without creating a rule;
     *  This is useful for one-off operations.
     */
    post: operations['TriggerWorkflowRule'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/cancel': {
    /**
     * @description RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
     *  a workflow execution.
     *
     *  This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
     *  workflow history and a new workflow task created for the workflow. It returns success if the requested
     *  workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
     */
    post: operations['RequestCancelWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/reset': {
    /**
     * @description ResetWorkflowExecution will reset an existing workflow execution to a specified
     *  `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
     *  execution instance.
     *  TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
     */
    post: operations['ResetWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/signal/{signalName}': {
    /**
     * @description SignalWorkflowExecution is used to send a signal to a running workflow execution.
     *
     *  This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
     *  task being created for the execution.
     */
    post: operations['SignalWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/terminate': {
    /**
     * @description TerminateWorkflowExecution terminates an existing workflow execution by recording a
     *  `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
     *  execution instance.
     */
    post: operations['TerminateWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update-options': {
    /** @description UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution. */
    post: operations['UpdateWorkflowExecutionOptions'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update/{request.input.name}': {
    /** @description Invokes the specified Update function on user Workflow code. */
    post: operations['UpdateWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowId}': {
    /**
     * @description StartWorkflowExecution starts a new workflow execution.
     *
     *  It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
     *  also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
     *  instance already exists with same workflow id.
     */
    post: operations['StartWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}': {
    /**
     * @description SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
     *  it isn't yet started.
     *
     *  If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
     *  and a workflow task is generated.
     *
     *  If the workflow is not running or not found, then the workflow is created with
     *  `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
     *  workflow task is generated.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "With" is used to indicate combined operation. --)
     */
    post: operations['SignalWithStartWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/execute-multi-operation': {
    /**
     * @description ExecuteMultiOperation executes multiple operations within a single workflow.
     *
     *  Operations are started atomically, meaning if *any* operation fails to be started, none are,
     *  and the request fails. Upon start, the API returns only when *all* operations have a response.
     *
     *  Upon failure, it returns `MultiOperationExecutionFailure` where the status code
     *  equals the status code of the *first* operation that failed to be started.
     *
     *  NOTE: Experimental API.
     */
    post: operations['ExecuteMultiOperation'];
  };
  '/api/v1/nexus/endpoints': {
    /**
     * @description List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
     *  next_page_token field of the previous response to get the next page of results. An empty next_page_token
     *  indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
     *  earlier than the previous page's last endpoint's ID may be missed.
     */
    get: operations['ListNexusEndpoints'];
    /**
     * @description Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
     *  ALREADY_EXISTS.
     *  Returns the created endpoint with its initial version. You may use this version for subsequent updates.
     */
    post: operations['CreateNexusEndpoint'];
  };
  '/api/v1/nexus/endpoints/{id}': {
    /** @description Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
    get: operations['GetNexusEndpoint'];
    /** @description Delete an incoming Nexus service by ID. */
    delete: operations['DeleteNexusEndpoint'];
  };
  '/api/v1/nexus/endpoints/{id}/update': {
    /**
     * @description Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
     *  `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
     *  match.
     *  Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
     *  need to increment the version yourself. The server will increment the version for you after each update.
     */
    post: operations['UpdateNexusEndpoint'];
  };
  '/api/v1/system-info': {
    /** @description GetSystemInfo returns information about the system. */
    get: operations['GetSystemInfo'];
  };
  '/cluster': {
    /** @description GetClusterInfo returns information about temporal cluster */
    get: operations['GetClusterInfo'];
  };
  '/cluster/namespaces': {
    /** @description ListNamespaces returns the information and configuration for all namespaces. */
    get: operations['ListNamespaces'];
    /**
     * @description RegisterNamespace creates a new namespace which can be used as a container for all resources.
     *
     *  A Namespace is a top level entity within Temporal, and is used as a container for resources
     *  like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
     *  isolation for all resources within the namespace. All resources belongs to exactly one
     *  namespace.
     */
    post: operations['RegisterNamespace'];
  };
  '/cluster/namespaces/{namespace}': {
    /** @description DescribeNamespace returns the information and configuration for a registered namespace. */
    get: operations['DescribeNamespace'];
  };
  '/cluster/namespaces/{namespace}/search-attributes': {
    /** @description ListSearchAttributes returns comprehensive information about search attributes. */
    get: operations['ListSearchAttributes'];
  };
  '/cluster/namespaces/{namespace}/update': {
    /**
     * @description UpdateNamespace is used to update the information and configuration of a registered
     *  namespace.
     */
    post: operations['UpdateNamespace'];
  };
  '/cluster/nexus/endpoints': {
    /**
     * @description List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
     *  next_page_token field of the previous response to get the next page of results. An empty next_page_token
     *  indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
     *  earlier than the previous page's last endpoint's ID may be missed.
     */
    get: operations['ListNexusEndpoints'];
    /**
     * @description Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
     *  ALREADY_EXISTS.
     *  Returns the created endpoint with its initial version. You may use this version for subsequent updates.
     */
    post: operations['CreateNexusEndpoint'];
  };
  '/cluster/nexus/endpoints/{id}': {
    /** @description Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
    get: operations['GetNexusEndpoint'];
    /** @description Delete an incoming Nexus service by ID. */
    delete: operations['DeleteNexusEndpoint'];
  };
  '/cluster/nexus/endpoints/{id}/update': {
    /**
     * @description Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
     *  `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
     *  match.
     *  Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
     *  need to increment the version yourself. The server will increment the version for you after each update.
     */
    post: operations['UpdateNexusEndpoint'];
  };
  '/namespaces/{namespace}/activities/cancel': {
    /**
     * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
     *
     *  This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
     *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *  no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCanceled'];
  };
  '/namespaces/{namespace}/activities/cancel-by-id': {
    /**
     * @description See `RecordActivityTaskCanceled`. This version allows clients to record failures by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskCanceledById'];
  };
  '/namespaces/{namespace}/activities/complete': {
    /**
     * @description RespondActivityTaskCompleted is called by workers when they successfully complete an activity
     *  task.
     *
     *  This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
     *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *  no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCompleted'];
  };
  '/namespaces/{namespace}/activities/complete-by-id': {
    /**
     * @description See `RecordActivityTaskCompleted`. This version allows clients to record completions by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskCompletedById'];
  };
  '/namespaces/{namespace}/activities/fail': {
    /**
     * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
     *
     *  This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
     *  a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
     *  longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskFailed'];
  };
  '/namespaces/{namespace}/activities/fail-by-id': {
    /**
     * @description See `RecordActivityTaskFailed`. This version allows clients to record failures by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskFailedById'];
  };
  '/namespaces/{namespace}/activities/heartbeat': {
    /**
     * @description RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
     *
     *  If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
     *  then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
     *  the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
     *  such situations, in that event, the SDK should request cancellation of the activity.
     */
    post: operations['RecordActivityTaskHeartbeat'];
  };
  '/namespaces/{namespace}/activities/heartbeat-by-id': {
    /**
     * @description See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RecordActivityTaskHeartbeatById'];
  };
  '/namespaces/{namespace}/activities/pause': {
    /**
     * @description PauseActivity pauses the execution of an activity specified by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be paused
     *
     *  Pausing an activity means:
     *  - If the activity is currently waiting for a retry or is running and subsequently fails,
     *    it will not be rescheduled until it is unpaused.
     *  - If the activity is already paused, calling this method will have no effect.
     *  - If the activity is running and finishes successfully, the activity will be completed.
     *  - If the activity is running and finishes with failure:
     *    * if there is no retry left - the activity will be completed.
     *    * if there are more retries left - the activity will be paused.
     *  For long-running activities:
     *  - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
     *  - The activity should respond to the cancellation accordingly.
     *
     *  Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['PauseActivity'];
  };
  '/namespaces/{namespace}/activities/reset': {
    /**
     * @description ResetActivity resets the execution of an activity specified by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be reset.
     *
     *  Resetting an activity means:
     *  * number of attempts will be reset to 0.
     *  * activity timeouts will be reset.
     *  * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
     *     it will be scheduled immediately (* see 'jitter' flag),
     *
     *  Flags:
     *
     *  'jitter': the activity will be scheduled at a random time within the jitter duration.
     *  If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
     *  'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
     *  'keep_paused': if the activity is paused, it will remain paused.
     *
     *  Returns a `NotFound` error if there is no pending activity with the provided ID or type.
     */
    post: operations['ResetActivity'];
  };
  '/namespaces/{namespace}/activities/unpause': {
    /**
     * @description UnpauseActivity unpauses the execution of an activity specified by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be unpaused.
     *
     *  If activity is not paused, this call will have no effect.
     *  If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
     *  Once the activity is unpaused, all timeout timers will be regenerated.
     *
     *  Flags:
     *  'jitter': the activity will be scheduled at a random time within the jitter duration.
     *  'reset_attempts': the number of attempts will be reset.
     *  'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
     *
     *  Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['UnpauseActivity'];
  };
  '/namespaces/{namespace}/activities/update-options': {
    /**
     * @description UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
     *  If there are multiple pending activities of the provided type - all of them will be updated.
     */
    post: operations['UpdateActivityOptions'];
  };
  '/namespaces/{namespace}/archived-workflows': {
    /** @description ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
    get: operations['ListArchivedWorkflowExecutions'];
  };
  '/namespaces/{namespace}/batch-operations': {
    /** @description ListBatchOperations returns a list of batch operations */
    get: operations['ListBatchOperations'];
  };
  '/namespaces/{namespace}/batch-operations/{jobId}': {
    /** @description DescribeBatchOperation returns the information about a batch operation */
    get: operations['DescribeBatchOperation'];
    /** @description StartBatchOperation starts a new batch operation */
    post: operations['StartBatchOperation'];
  };
  '/namespaces/{namespace}/batch-operations/{jobId}/stop': {
    /** @description StopBatchOperation stops a batch operation */
    post: operations['StopBatchOperation'];
  };
  '/namespaces/{namespace}/current-deployment/{deployment.series_name}': {
    /**
     * @description Sets a deployment as the current deployment for its deployment series. Can optionally update
     *  the metadata of the deployment as well.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
     */
    post: operations['SetCurrentDeployment'];
  };
  '/namespaces/{namespace}/current-deployment/{seriesName}': {
    /**
     * @description Returns the current deployment (and its info) for a given deployment series.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
     */
    get: operations['GetCurrentDeployment'];
  };
  '/namespaces/{namespace}/deployments': {
    /**
     * @description Lists worker deployments in the namespace. Optionally can filter based on deployment series
     *  name.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced with `ListWorkerDeployments`.
     */
    get: operations['ListDeployments'];
  };
  '/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}': {
    /**
     * @description Describes a worker deployment.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
     */
    get: operations['DescribeDeployment'];
  };
  '/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}/reachability': {
    /**
     * @description Returns the reachability level of a worker deployment to help users decide when it is time
     *  to decommission a deployment. Reachability level is calculated based on the deployment's
     *  `status` and existing workflows that depend on the given deployment for their execution.
     *  Calculating reachability is relatively expensive. Therefore, server might return a recently
     *  cached value. In such a case, the `last_update_time` will inform you about the actual
     *  reachability calculation time.
     *  Experimental. This API might significantly change or be removed in a future release.
     *  Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
     */
    get: operations['GetDeploymentReachability'];
  };
  '/namespaces/{namespace}/schedules': {
    /** @description List all schedules in a namespace. */
    get: operations['ListSchedules'];
  };
  '/namespaces/{namespace}/schedules/{scheduleId}': {
    /** @description Returns the schedule description and current state of an existing schedule. */
    get: operations['DescribeSchedule'];
    /** @description Creates a new schedule. */
    post: operations['CreateSchedule'];
    /** @description Deletes a schedule, removing it from the system. */
    delete: operations['DeleteSchedule'];
  };
  '/namespaces/{namespace}/schedules/{scheduleId}/matching-times': {
    /** @description Lists matching times within a range. */
    get: operations['ListScheduleMatchingTimes'];
  };
  '/namespaces/{namespace}/schedules/{scheduleId}/patch': {
    /** @description Makes a specific change to a schedule or triggers an immediate action. */
    post: operations['PatchSchedule'];
  };
  '/namespaces/{namespace}/schedules/{scheduleId}/update': {
    /** @description Changes the configuration or state of an existing schedule. */
    post: operations['UpdateSchedule'];
  };
  '/namespaces/{namespace}/task-queues/{task_queue.name}': {
    /**
     * @description DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
     *    - List of pollers
     *    - Workflow Reachability status
     *    - Backlog info for Workflow and/or Activity tasks
     */
    get: operations['DescribeTaskQueue'];
  };
  '/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility': {
    /**
     * @description Deprecated. Use `GetWorkerVersioningRules`.
     *  Fetches the worker build id versioning sets for a task queue.
     */
    get: operations['GetWorkerBuildIdCompatibility'];
  };
  '/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules': {
    /**
     * @description Fetches the Build ID assignment and redirect rules for a Task Queue.
     *  WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
     */
    get: operations['GetWorkerVersioningRules'];
  };
  '/namespaces/{namespace}/worker-deployment-versions/{version}': {
    /**
     * @description Describes a worker deployment version.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    get: operations['DescribeWorkerDeploymentVersion'];
    /**
     * @description Used for manual deletion of Versions. User can delete a Version only when all the
     *  following conditions are met:
     *   - It is not the Current or Ramping Version of its Deployment.
     *   - It has no active pollers (none of the task queues in the Version have pollers)
     *   - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
     *     can be skipped by passing `skip-drainage=true`.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    delete: operations['DeleteWorkerDeploymentVersion'];
  };
  '/namespaces/{namespace}/worker-deployment-versions/{version}/update-metadata': {
    /**
     * @description Updates the user-given metadata attached to a Worker Deployment Version.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    post: operations['UpdateWorkerDeploymentVersionMetadata'];
  };
  '/namespaces/{namespace}/worker-deployments': {
    /**
     * @description Lists all Worker Deployments that are tracked in the Namespace.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    get: operations['ListWorkerDeployments'];
  };
  '/namespaces/{namespace}/worker-deployments/{deploymentName}': {
    /**
     * @description Describes a Worker Deployment.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    get: operations['DescribeWorkerDeployment'];
    /**
     * @description Deletes records of (an old) Deployment. A deployment can only be deleted if
     *  it has no Version in it.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    delete: operations['DeleteWorkerDeployment'];
  };
  '/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version': {
    /**
     * @description Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
     *  Version if it is the Version being set as Current.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    post: operations['SetWorkerDeploymentCurrentVersion'];
  };
  '/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version': {
    /**
     * @description Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
     *  gradual ramp to unversioned workers too.
     *  Experimental. This API might significantly change or be removed in a future release.
     */
    post: operations['SetWorkerDeploymentRampingVersion'];
  };
  '/namespaces/{namespace}/worker-task-reachability': {
    /**
     * @description Deprecated. Use `DescribeTaskQueue`.
     *
     *  Fetches task reachability to determine whether a worker may be retired.
     *  The request may specify task queues to query for or let the server fetch all task queues mapped to the given
     *  build IDs.
     *
     *  When requesting a large number of task queues or all task queues associated with the given build ids in a
     *  namespace, all task queues will be listed in the response but some of them may not contain reachability
     *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
     *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
     *  another call to get the reachability for those task queues.
     *
     *  Open source users can adjust this limit by setting the server's dynamic config value for
     *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
     */
    get: operations['GetWorkerTaskReachability'];
  };
  '/namespaces/{namespace}/workflow-count': {
    /** @description CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
    get: operations['CountWorkflowExecutions'];
  };
  '/namespaces/{namespace}/workflow-rules': {
    /** @description Return all namespace workflow rules */
    get: operations['ListWorkflowRules'];
    /**
     * @description Create a new workflow rule. The rules are used to control the workflow execution.
     *  The rule will be applied to all running and new workflows in the namespace.
     *  If the rule with such ID already exist this call will fail
     *  Note: the rules are part of namespace configuration and will be stored in the namespace config.
     *  Namespace config is eventually consistent.
     */
    post: operations['CreateWorkflowRule'];
  };
  '/namespaces/{namespace}/workflow-rules/{ruleId}': {
    /**
     * @description DescribeWorkflowRule return the rule specification for existing rule id.
     *  If there is no rule with such id - NOT FOUND error will be returned.
     */
    get: operations['DescribeWorkflowRule'];
    /** @description Delete rule by rule id */
    delete: operations['DeleteWorkflowRule'];
  };
  '/namespaces/{namespace}/workflows': {
    /** @description ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
    get: operations['ListWorkflowExecutions'];
  };
  '/namespaces/{namespace}/workflows/{execution.workflow_id}': {
    /** @description DescribeWorkflowExecution returns information about the specified workflow execution. */
    get: operations['DescribeWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{execution.workflow_id}/history': {
    /**
     * @description GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
     *  `NotFound` if the specified workflow execution is unknown to the service.
     */
    get: operations['GetWorkflowExecutionHistory'];
  };
  '/namespaces/{namespace}/workflows/{execution.workflow_id}/history-reverse': {
    /**
     * @description GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
     *  order (starting from last event). Fails with`NotFound` if the specified workflow execution is
     *  unknown to the service.
     */
    get: operations['GetWorkflowExecutionHistoryReverse'];
  };
  '/namespaces/{namespace}/workflows/{execution.workflow_id}/query/{query.query_type}': {
    /** @description QueryWorkflow requests a query be executed for a specified workflow execution. */
    post: operations['QueryWorkflow'];
  };
  '/namespaces/{namespace}/workflows/{execution.workflow_id}/trigger-rule': {
    /**
     * @description TriggerWorkflowRule allows to:
     *   * trigger existing rule for a specific workflow execution;
     *   * trigger rule for a specific workflow execution without creating a rule;
     *  This is useful for one-off operations.
     */
    post: operations['TriggerWorkflowRule'];
  };
  '/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/cancel': {
    /**
     * @description RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
     *  a workflow execution.
     *
     *  This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
     *  workflow history and a new workflow task created for the workflow. It returns success if the requested
     *  workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
     */
    post: operations['RequestCancelWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/reset': {
    /**
     * @description ResetWorkflowExecution will reset an existing workflow execution to a specified
     *  `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
     *  execution instance.
     *  TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
     */
    post: operations['ResetWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/signal/{signalName}': {
    /**
     * @description SignalWorkflowExecution is used to send a signal to a running workflow execution.
     *
     *  This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
     *  task being created for the execution.
     */
    post: operations['SignalWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/terminate': {
    /**
     * @description TerminateWorkflowExecution terminates an existing workflow execution by recording a
     *  `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
     *  execution instance.
     */
    post: operations['TerminateWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update-options': {
    /** @description UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution. */
    post: operations['UpdateWorkflowExecutionOptions'];
  };
  '/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update/{request.input.name}': {
    /** @description Invokes the specified Update function on user Workflow code. */
    post: operations['UpdateWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{workflowId}': {
    /**
     * @description StartWorkflowExecution starts a new workflow execution.
     *
     *  It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
     *  also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
     *  instance already exists with same workflow id.
     */
    post: operations['StartWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}': {
    /**
     * @description SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
     *  it isn't yet started.
     *
     *  If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
     *  and a workflow task is generated.
     *
     *  If the workflow is not running or not found, then the workflow is created with
     *  `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
     *  workflow task is generated.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "With" is used to indicate combined operation. --)
     */
    post: operations['SignalWithStartWorkflowExecution'];
  };
  '/namespaces/{namespace}/workflows/execute-multi-operation': {
    /**
     * @description ExecuteMultiOperation executes multiple operations within a single workflow.
     *
     *  Operations are started atomically, meaning if *any* operation fails to be started, none are,
     *  and the request fails. Upon start, the API returns only when *all* operations have a response.
     *
     *  Upon failure, it returns `MultiOperationExecutionFailure` where the status code
     *  equals the status code of the *first* operation that failed to be started.
     *
     *  NOTE: Experimental API.
     */
    post: operations['ExecuteMultiOperation'];
  };
  '/system-info': {
    /** @description GetSystemInfo returns information about the system. */
    get: operations['GetSystemInfo'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    readonly ActivityFailureInfo: {
      readonly activityId?: string;
      readonly activityType?: components['schemas']['ActivityType'];
      readonly identity?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      readonly scheduledEventId?: string;
      readonly startedEventId?: string;
    };
    readonly ActivityOptions: {
      /** @description Maximum permitted time between successful worker heartbeats. */
      readonly heartbeatTimeout?: string;
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      /**
       * @description Indicates how long the caller is willing to wait for an activity completion. Limits how long
       *  retries will be attempted. Either this or `start_to_close_timeout` must be specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly scheduleToCloseTimeout?: string;
      /**
       * @description Limits time an activity task can stay in a task queue before a worker picks it up. This
       *  timeout is always non retryable, as all a retry would achieve is to put it back into the same
       *  queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
       *  specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly scheduleToStartTimeout?: string;
      /**
       * @description Maximum time an activity is allowed to execute after being picked up by a worker. This
       *  timeout is always retryable. Either this or `schedule_to_close_timeout` must be
       *  specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly startToCloseTimeout?: string;
      readonly taskQueue?: components['schemas']['TaskQueue'];
    };
    readonly ActivityPropertiesModifiedExternallyEventAttributes: {
      /**
       * @description If set, update the retry policy of the activity, replacing it with the specified one.
       *  The number of attempts at the activity is preserved.
       */
      readonly newRetryPolicy?: components['schemas']['RetryPolicy'];
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to. */
      readonly scheduledEventId?: string;
    };
    readonly ActivityTaskCanceledEventAttributes: {
      /** @description Additional information that the activity reported upon confirming cancellation */
      readonly details?: components['schemas']['Payloads'];
      /** @description id of the worker who canceled this activity */
      readonly identity?: string;
      /**
       * @description id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same
       *  activity
       */
      readonly latestCancelRequestedEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to */
      readonly scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to */
      readonly startedEventId?: string;
      /**
       * @description Version info of the worker who processed this workflow task.
       *  Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly ActivityTaskCancelRequestedEventAttributes: {
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to */
      readonly scheduledEventId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly ActivityTaskCompletedEventAttributes: {
      /** @description id of the worker that completed this task */
      readonly identity?: string;
      /** @description Serialized results of the activity. IE: The return value of the activity function */
      readonly result?: components['schemas']['Payloads'];
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to */
      readonly scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to */
      readonly startedEventId?: string;
      /**
       * @description Version info of the worker who processed this workflow task.
       *  Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly ActivityTaskFailedEventAttributes: {
      /** @description Failure details */
      readonly failure?: components['schemas']['Failure'];
      /** @description id of the worker that failed this task */
      readonly identity?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to */
      readonly scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to */
      readonly startedEventId?: string;
      /**
       * @description Version info of the worker who processed this workflow task.
       *  Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly ActivityTaskScheduledEventAttributes: {
      /** @description The worker/user assigned identifier for the activity */
      readonly activityId?: string;
      readonly activityType?: components['schemas']['ActivityType'];
      readonly header?: components['schemas']['Header'];
      /** @description Maximum permitted time between successful worker heartbeats. */
      readonly heartbeatTimeout?: string;
      readonly input?: components['schemas']['Payloads'];
      /**
       * @description Priority metadata. If this message is not present, or any fields are not
       *  present, they inherit the values from the workflow.
       */
      readonly priority?: components['schemas']['Priority'];
      /**
       * @description Activities are assigned a default retry policy controlled by the service's dynamic
       *  configuration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set
       *  retry_policy.maximum_attempts to 1.
       */
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      /**
       * @description Indicates how long the caller is willing to wait for an activity completion. Limits how long
       *  retries will be attempted. Either this or `start_to_close_timeout` must be specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly scheduleToCloseTimeout?: string;
      /**
       * @description Limits time an activity task can stay in a task queue before a worker picks it up. This
       *  timeout is always non retryable, as all a retry would achieve is to put it back into the same
       *  queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
       *  specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly scheduleToStartTimeout?: string;
      /**
       * @description Maximum time an activity is allowed to execute after being picked up by a worker. This
       *  timeout is always retryable. Either this or `schedule_to_close_timeout` must be
       *  specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly startToCloseTimeout?: string;
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /**
       * @description If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
       *  Assignment rules of the activity's Task Queue will be used to determine the Build ID.
       */
      readonly useWorkflowBuildId?: boolean;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly ActivityTaskStartedEventAttributes: {
      /**
       * Format: int32
       * @description Starting at 1, the number of times this task has been attempted
       */
      readonly attempt?: number;
      /**
       * @description Used by server internally to properly reapply build ID redirects to an execution
       *  when rebuilding it from events.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly buildIdRedirectCounter?: string;
      /** @description id of the worker that picked up this task */
      readonly identity?: string;
      /**
       * @description Will be set to the most recent failure details, if this task has previously failed and then
       *  been retried.
       */
      readonly lastFailure?: components['schemas']['Failure'];
      /** @description TODO ?? */
      readonly requestId?: string;
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to */
      readonly scheduledEventId?: string;
      /**
       * @description Version info of the worker to whom this task was dispatched.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly ActivityTaskTimedOutEventAttributes: {
      /**
       * @description If this activity had failed, was retried, and then timed out, that failure is stored as the
       *  `cause` in here.
       */
      readonly failure?: components['schemas']['Failure'];
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to */
      readonly scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to */
      readonly startedEventId?: string;
    };
    /**
     * @description Represents the identifier used by a activity author to define the activity. Typically, the
     *  name of a function. This is sometimes referred to as the activity's "name"
     */
    readonly ActivityType: {
      readonly name?: string;
    };
    /** @description Alert contains notification and severity. */
    readonly Alert: {
      readonly message?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly severity?:
        | 'SEVERITY_UNSPECIFIED'
        | 'SEVERITY_HIGH'
        | 'SEVERITY_MEDIUM'
        | 'SEVERITY_LOW';
    };
    readonly ApplicationFailureInfo: {
      readonly details?: components['schemas']['Payloads'];
      /**
       * @description next_retry_delay can be used by the client to override the activity
       *  retry interval calculated by the retry policy. Retry attempts will
       *  still be subject to the maximum retries limit and total time limit
       *  defined by the policy.
       */
      readonly nextRetryDelay?: string;
      readonly nonRetryable?: boolean;
      readonly type?: string;
    };
    readonly BackfillRequest: {
      /** Format: date-time */
      readonly endTime?: string;
      /**
       * Format: enum
       * @description If set, override overlap policy for this request.
       * @enum {string}
       */
      readonly overlapPolicy?:
        | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
        | 'SCHEDULE_OVERLAP_POLICY_SKIP'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
        | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
      /**
       * Format: date-time
       * @description Time range to evaluate schedule in. Currently, this time range is
       *  exclusive on start_time and inclusive on end_time. (This is admittedly
       *  counterintuitive and it may change in the future, so to be safe, use a
       *  start time strictly before a scheduled time.) Also note that an action
       *  nominally scheduled in the interval but with jitter that pushes it after
       *  end_time will not be included.
       */
      readonly startTime?: string;
    };
    readonly BadBinaries: {
      readonly binaries?: {
        [key: string]: components['schemas']['BadBinaryInfo'];
      };
    };
    readonly BadBinaryInfo: {
      /** Format: date-time */
      readonly createTime?: string;
      readonly operator?: string;
      readonly reason?: string;
    };
    /**
     * @description BatchOperationCancellation sends cancel requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
     *  Ignore first_execution_run_id because this is used for single workflow operation.
     */
    readonly BatchOperationCancellation: {
      /** @description The identity of the worker/client */
      readonly identity?: string;
    };
    /**
     * @description BatchOperationDeletion sends deletion requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
     */
    readonly BatchOperationDeletion: {
      /** @description The identity of the worker/client */
      readonly identity?: string;
    };
    readonly BatchOperationInfo: {
      /**
       * Format: date-time
       * @description Batch operation close time
       */
      readonly closeTime?: string;
      /** @description Batch job ID */
      readonly jobId?: string;
      /**
       * Format: date-time
       * @description Batch operation start time
       */
      readonly startTime?: string;
      /**
       * Format: enum
       * @description Batch operation state
       * @enum {string}
       */
      readonly state?:
        | 'BATCH_OPERATION_STATE_UNSPECIFIED'
        | 'BATCH_OPERATION_STATE_RUNNING'
        | 'BATCH_OPERATION_STATE_COMPLETED'
        | 'BATCH_OPERATION_STATE_FAILED';
    };
    /**
     * @description BatchOperationReset sends reset requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
     */
    readonly BatchOperationReset: {
      /** @description The identity of the worker/client. */
      readonly identity?: string;
      /** @description Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored. */
      readonly options?: components['schemas']['ResetOptions'];
      /**
       * Format: enum
       * @description History event reapply options (deprecated, use `options`).
       * @enum {string}
       */
      readonly resetReapplyType?:
        | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_TYPE_SIGNAL'
        | 'RESET_REAPPLY_TYPE_NONE'
        | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
      /**
       * Format: enum
       * @description Reset type (deprecated, use `options`).
       * @enum {string}
       */
      readonly resetType?:
        | 'RESET_TYPE_UNSPECIFIED'
        | 'RESET_TYPE_FIRST_WORKFLOW_TASK'
        | 'RESET_TYPE_LAST_WORKFLOW_TASK';
    };
    /**
     * @description BatchOperationSignal sends signals to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
     */
    readonly BatchOperationSignal: {
      /**
       * @description Headers that are passed with the signal to the processing workflow.
       *  These can include things like auth or tracing tokens.
       */
      readonly header?: components['schemas']['Header'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Serialized value(s) to provide with the signal */
      readonly input?: components['schemas']['Payloads'];
      /** @description The workflow author-defined name of the signal to send to the workflow */
      readonly signal?: string;
    };
    /**
     * @description BatchOperationTermination sends terminate requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
     *  Ignore first_execution_run_id because this is used for single workflow operation.
     */
    readonly BatchOperationTermination: {
      /** @description Serialized value(s) to provide to the termination event */
      readonly details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
    };
    /** @description BatchOperationUnpauseActivities sends unpause requests to batch workflows. */
    readonly BatchOperationUnpauseActivities: {
      /** @description The identity of the worker/client. */
      readonly identity?: string;
      /**
       * @description If set, the activity will start at a random time within the specified jitter
       *  duration, introducing variability to the start time.
       */
      readonly jitter?: string;
      readonly matchAll?: boolean;
      /** @description Providing this flag will also reset the number of attempts. */
      readonly resetAttempts?: boolean;
      /** @description Providing this flag will also reset the heartbeat details. */
      readonly resetHeartbeat?: boolean;
      readonly type?: string;
    };
    /**
     * @description BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.
     *  Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
     */
    readonly BatchOperationUpdateWorkflowExecutionOptions: {
      /** @description The identity of the worker/client. */
      readonly identity?: string;
      /**
       * Format: field-mask
       * @description Controls which fields from `workflow_execution_options` will be applied.
       *  To unset a field, set it to null and use the update mask to indicate that it should be mutated.
       */
      readonly updateMask?: string;
      /** @description Workflow Execution options. Partial updates are accepted and controlled by update_mask. */
      readonly workflowExecutionOptions?: components['schemas']['WorkflowExecutionOptions'];
    };
    /**
     * @description Assignment rules are applied to *new* Workflow and Activity executions at
     *  schedule time to assign them to a Build ID.
     *
     *  Assignment rules will not be used in the following cases:
     *     - Child Workflows or Continue-As-New Executions who inherit their
     *       parent/previous Workflow's assigned Build ID (by setting the
     *       `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
     *       is used.)
     *     - An Activity that inherits the assigned Build ID of its Workflow (by
     *       setting the `use_workflow_build_id` flag - default behavior in SDKs
     *       when the same Task Queue is used.)
     *
     *  In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
     *  the task will be dispatched to Workers of the Build ID determined by the
     *  assignment rules (or inherited). Otherwise, the final Build ID will be
     *  determined by the redirect rules.
     *
     *  Once a Workflow completes its first Workflow Task in a particular Build ID it
     *  stays in that Build ID regardless of changes to assignment rules. Redirect
     *  rules can be used to move the workflow to another compatible Build ID.
     *
     *  When using Worker Versioning on a Task Queue, in the steady state,
     *  there should typically be a single assignment rule to send all new executions
     *  to the latest Build ID. Existence of at least one such "unconditional"
     *  rule at all times is enforces by the system, unless the `force` flag is used
     *  by the user when replacing/deleting these rules (for exceptional cases).
     *
     *  During a deployment, one or more additional rules can be added to assign a
     *  subset of the tasks to a new Build ID based on a "ramp percentage".
     *
     *  When there are multiple assignment rules for a Task Queue, the rules are
     *  evaluated in order, starting from index 0. The first applicable rule will be
     *  applied and the rest will be ignored.
     *
     *  In the event that no assignment rule is applicable on a task (or the Task
     *  Queue is simply not versioned), the tasks will be dispatched to an
     *  unversioned Worker.
     */
    readonly BuildIdAssignmentRule: {
      /**
       * @description This ramp is useful for gradual Blue/Green deployments (and similar)
       *  where you want to send a certain portion of the traffic to the target
       *  Build ID.
       */
      readonly percentageRamp?: components['schemas']['RampByPercentage'];
      readonly targetBuildId?: string;
    };
    /** @description Reachability of tasks for a worker by build id, in one or more task queues. */
    readonly BuildIdReachability: {
      /** @description A build id or empty if unversioned. */
      readonly buildId?: string;
      /** @description Reachability per task queue. */
      readonly taskQueueReachability?: readonly components['schemas']['TaskQueueReachability'][];
    };
    /**
     * @description CalendarSpec describes an event specification relative to the calendar,
     *  similar to a traditional cron specification, but with labeled fields. Each
     *  field can be one of:
     *    *: matches always
     *    x: matches when the field equals x
     *    x/y : matches when the field equals x+n*y where n is an integer
     *    x-z: matches when the field is between x and z inclusive
     *    w,x,y,...: matches when the field is one of the listed values
     *  Each x, y, z, ... is either a decimal integer, or a month or day of week name
     *  or abbreviation (in the appropriate fields).
     *  A timestamp matches if all fields match.
     *  Note that fields have different default values, for convenience.
     *  Note that the special case that some cron implementations have for treating
     *  day_of_month and day_of_week as "or" instead of "and" when both are set is
     *  not implemented.
     *  day_of_week can accept 0 or 7 as Sunday
     *  CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
     *  returned if you describe the schedule.
     */
    readonly CalendarSpec: {
      /** @description Free-form comment describing the intention of this spec. */
      readonly comment?: string;
      /**
       * @description Expression to match days of the month. Default: *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: standard name of field --)
       */
      readonly dayOfMonth?: string;
      /** @description Expression to match days of the week. Default: * */
      readonly dayOfWeek?: string;
      /** @description Expression to match hours. Default: 0 */
      readonly hour?: string;
      /** @description Expression to match minutes. Default: 0 */
      readonly minute?: string;
      /** @description Expression to match months. Default: * */
      readonly month?: string;
      /** @description Expression to match seconds. Default: 0 */
      readonly second?: string;
      /** @description Expression to match years. Default: * */
      readonly year?: string;
    };
    /** @description Callback to attach to various events in the system, e.g. workflow run completion. */
    readonly Callback: {
      readonly internal?: components['schemas']['Callback_Internal'];
      readonly nexus?: components['schemas']['Callback_Nexus'];
    };
    /**
     * @description Callbacks to be delivered internally within the system.
     *  This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.
     *  The only reason that this is exposed is because callbacks are replicated across clusters via the
     *  WorkflowExecutionStarted event, which is defined in the public API.
     */
    readonly Callback_Internal: {
      /**
       * Format: bytes
       * @description Opaque internal data.
       */
      readonly data?: string;
    };
    readonly Callback_Nexus: {
      /** @description Header to attach to callback request. */
      readonly header?: {
        [key: string]: string;
      };
      /** @description Callback URL. */
      readonly url?: string;
    };
    /** @description CallbackInfo contains the state of an attached workflow callback. */
    readonly CallbackInfo: {
      /**
       * Format: int32
       * @description The number of attempts made to deliver the callback.
       *  This number represents a minimum bound since the attempt is incremented after the callback request completes.
       */
      readonly attempt?: number;
      /** @description If the state is BLOCKED, blocked reason provides additional information. */
      readonly blockedReason?: string;
      /** @description Information on how this callback should be invoked (e.g. its URL and type). */
      readonly callback?: components['schemas']['Callback'];
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      readonly lastAttemptCompleteTime?: string;
      /** @description The last attempt's failure, if any. */
      readonly lastAttemptFailure?: components['schemas']['Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      readonly nextAttemptScheduleTime?: string;
      /**
       * Format: date-time
       * @description The time when the callback was registered.
       */
      readonly registrationTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'CALLBACK_STATE_UNSPECIFIED'
        | 'CALLBACK_STATE_STANDBY'
        | 'CALLBACK_STATE_SCHEDULED'
        | 'CALLBACK_STATE_BACKING_OFF'
        | 'CALLBACK_STATE_FAILED'
        | 'CALLBACK_STATE_SUCCEEDED'
        | 'CALLBACK_STATE_BLOCKED';
      /** @description Trigger for this callback. */
      readonly trigger?: components['schemas']['CallbackInfo_Trigger'];
    };
    readonly CallbackInfo_Trigger: {
      readonly workflowClosed?: components['schemas']['CallbackInfo_WorkflowClosed'];
    };
    /** @description Trigger for when the workflow is closed. */
    readonly CallbackInfo_WorkflowClosed: Record<string, unknown>;
    readonly CanceledFailureInfo: {
      readonly details?: components['schemas']['Payloads'];
    };
    readonly ChildWorkflowExecutionCanceledEventAttributes: {
      readonly details?: components['schemas']['Payloads'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      readonly startedEventId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ChildWorkflowExecutionCompletedEventAttributes: {
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly result?: components['schemas']['Payloads'];
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      readonly startedEventId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ChildWorkflowExecutionFailedEventAttributes: {
      readonly failure?: components['schemas']['Failure'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      readonly startedEventId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ChildWorkflowExecutionFailureInfo: {
      readonly initiatedEventId?: string;
      readonly namespace?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      readonly startedEventId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ChildWorkflowExecutionStartedEventAttributes: {
      readonly header?: components['schemas']['Header'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ChildWorkflowExecutionTerminatedEventAttributes: {
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      readonly startedEventId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ChildWorkflowExecutionTimedOutEventAttributes: {
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      readonly startedEventId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly ClusterReplicationConfig: {
      readonly clusterName?: string;
    };
    /**
     * @description These rules apply to tasks assigned to a particular Build ID
     *  (`source_build_id`) to redirect them to another *compatible* Build ID
     *  (`target_build_id`).
     *
     *  It is user's responsibility to ensure that the target Build ID is compatible
     *  with the source Build ID (e.g. by using the Patching API).
     *
     *  Most deployments are not expected to need these rules, however following
     *  situations can greatly benefit from redirects:
     *   - Need to move long-running Workflow Executions from an old Build ID to a
     *     newer one.
     *   - Need to hotfix some broken or stuck Workflow Executions.
     *
     *  In steady state, redirect rules are beneficial when dealing with old
     *  Executions ran on now-decommissioned Build IDs:
     *   - To redirecting the Workflow Queries to the current (compatible) Build ID.
     *   - To be able to Reset an old Execution so it can run on the current
     *     (compatible) Build ID.
     *
     *  Redirect rules can be chained.
     */
    readonly CompatibleBuildIdRedirectRule: {
      readonly sourceBuildId?: string;
      /**
       * @description Target Build ID must be compatible with the Source Build ID; that is it
       *  must be able to process event histories made by the Source Build ID by
       *  using [Patching](https://docs.temporal.io/workflows#patching) or other
       *  means.
       */
      readonly targetBuildId?: string;
    };
    /**
     * @description Used by the worker versioning APIs, represents an unordered set of one or more versions which are
     *  considered to be compatible with each other. Currently the versions are always worker build IDs.
     */
    readonly CompatibleVersionSet: {
      /** @description All the compatible versions, unordered, except for the last element, which is considered the set "default". */
      readonly buildIds?: readonly string[];
    };
    readonly CountWorkflowExecutionsResponse: {
      /**
       * @description If `query` is not grouping by any field, the count is an approximate number
       *  of workflows that matches the query.
       *  If `query` is grouping by a field, the count is simply the sum of the counts
       *  of the groups returned in the response. This number can be smaller than the
       *  total number of workflows matching the query.
       */
      readonly count?: string;
      /**
       * @description `groups` contains the groups if the request is grouping by a field.
       *  The list might not be complete, and the counts of each group is approximate.
       */
      readonly groups?: readonly components['schemas']['CountWorkflowExecutionsResponse_AggregationGroup'][];
    };
    readonly CountWorkflowExecutionsResponse_AggregationGroup: {
      readonly count?: string;
      readonly groupValues?: readonly components['schemas']['Payload'][];
    };
    readonly CreateNexusEndpointRequest: {
      /** @description Endpoint definition to create. */
      readonly spec?: components['schemas']['EndpointSpec'];
    };
    readonly CreateNexusEndpointResponse: {
      /** @description Data post acceptance. Can be used to issue additional updates to this record. */
      readonly endpoint?: components['schemas']['Endpoint'];
    };
    /**
     * @description (-- api-linter: core::0203::optional=disabled
     *      aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
     */
    readonly CreateScheduleRequest: {
      /** @description The identity of the client who initiated this request. */
      readonly identity?: string;
      /** @description Optional initial patch (e.g. to run the action once immediately). */
      readonly initialPatch?: components['schemas']['SchedulePatch'];
      /** @description Memo and search attributes to attach to the schedule itself. */
      readonly memo?: components['schemas']['Memo'];
      /** @description The namespace the schedule should be created in. */
      readonly namespace?: string;
      /** @description A unique identifier for this create request for idempotence. Typically UUIDv4. */
      readonly requestId?: string;
      /** @description The schedule spec, policies, action, and initial state. */
      readonly schedule?: components['schemas']['Schedule'];
      /** @description The id of the new schedule. */
      readonly scheduleId?: string;
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
    };
    readonly CreateScheduleResponse: {
      /** Format: bytes */
      readonly conflictToken?: string;
    };
    readonly CreateWorkflowRuleRequest: {
      /**
       * @description If true, the rule will be applied to the currently running workflows via batch job.
       *  If not set , the rule will only be applied when triggering condition is satisfied.
       *  visibility_query in the rule will be used to select the workflows to apply the rule to.
       */
      readonly forceScan?: boolean;
      readonly namespace?: string;
      /** @description Used to de-dupe requests. Typically should be UUID. */
      readonly requestId?: string;
      /** @description The rule specification . */
      readonly spec?: components['schemas']['WorkflowRuleSpec'];
    };
    readonly CreateWorkflowRuleResponse: {
      /** @description Batch Job ID if force-scan flag was provided. Otherwise empty. */
      readonly jobId?: string;
      /** @description Created rule. */
      readonly rule?: components['schemas']['WorkflowRule'];
    };
    readonly DataBlob: {
      /** Format: bytes */
      readonly data?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly encodingType?:
        | 'ENCODING_TYPE_UNSPECIFIED'
        | 'ENCODING_TYPE_PROTO3'
        | 'ENCODING_TYPE_JSON';
    };
    readonly DeleteNexusEndpointResponse: Record<string, unknown>;
    readonly DeleteScheduleResponse: Record<string, unknown>;
    readonly DeleteWorkerDeploymentResponse: Record<string, unknown>;
    readonly DeleteWorkerDeploymentVersionResponse: Record<string, unknown>;
    readonly DeleteWorkflowRuleResponse: Record<string, unknown>;
    /**
     * @description `Deployment` identifies a deployment of Temporal workers. The combination of deployment series
     *  name + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker
     *  programs to specify these values.
     *  Deprecated.
     */
    readonly Deployment: {
      /**
       * @description Build ID changes with each version of the worker when the worker program code and/or config
       *  changes.
       */
      readonly buildId?: string;
      /**
       * @description Different versions of the same worker service/application are related together by having a
       *  shared series name.
       *  Out of all deployments of a series, one can be designated as the current deployment, which
       *  receives new workflow executions and new tasks of workflows with
       *  `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.
       */
      readonly seriesName?: string;
    };
    /**
     * @description `DeploymentInfo` holds information about a deployment. Deployment information is tracked
     *  automatically by server as soon as the first poll from that deployment reaches the server. There
     *  can be multiple task queue workers in a single deployment which are listed in this message.
     *  Deprecated.
     */
    readonly DeploymentInfo: {
      /** Format: date-time */
      readonly createTime?: string;
      readonly deployment?: components['schemas']['Deployment'];
      /** @description If this deployment is the current deployment of its deployment series. */
      readonly isCurrent?: boolean;
      /**
       * @description A user-defined set of key-values. Can be updated as part of write operations to the
       *  deployment, such as `SetCurrentDeployment`.
       */
      readonly metadata?: {
        [key: string]: components['schemas']['Payload'];
      };
      readonly taskQueueInfos?: readonly components['schemas']['DeploymentInfo_TaskQueueInfo'][];
    };
    readonly DeploymentInfo_TaskQueueInfo: {
      /**
       * Format: date-time
       * @description When server saw the first poller for this task queue in this deployment.
       */
      readonly firstPollerTime?: string;
      readonly name?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly type?:
        | 'TASK_QUEUE_TYPE_UNSPECIFIED'
        | 'TASK_QUEUE_TYPE_WORKFLOW'
        | 'TASK_QUEUE_TYPE_ACTIVITY'
        | 'TASK_QUEUE_TYPE_NEXUS';
    };
    /**
     * @description DeploymentListInfo is an abbreviated set of fields from DeploymentInfo that's returned in
     *  ListDeployments.
     *  Deprecated.
     */
    readonly DeploymentListInfo: {
      /** Format: date-time */
      readonly createTime?: string;
      readonly deployment?: components['schemas']['Deployment'];
      /** @description If this deployment is the current deployment of its deployment series. */
      readonly isCurrent?: boolean;
    };
    /**
     * @description Holds information about ongoing transition of a workflow execution from one deployment to another.
     *  Deprecated. Use DeploymentVersionTransition.
     */
    readonly DeploymentTransition: {
      /**
       * @description The target deployment of the transition. Null means a so-far-versioned workflow is
       *  transitioning to unversioned workers.
       */
      readonly deployment?: components['schemas']['Deployment'];
    };
    /**
     * @description Holds information about ongoing transition of a workflow execution from one worker
     *  deployment version to another.
     *  Experimental. Might change in the future.
     */
    readonly DeploymentVersionTransition: {
      /**
       * @description Required. The target Version of the transition. May be `__unversioned__` which means a
       *  so-far-versioned workflow is transitioning to unversioned workers.
       */
      readonly version?: string;
    };
    readonly DescribeBatchOperationResponse: {
      /**
       * Format: date-time
       * @description Batch operation close time
       */
      readonly closeTime?: string;
      /** @description Complete operation count */
      readonly completeOperationCount?: string;
      /** @description Failure operation count */
      readonly failureOperationCount?: string;
      /** @description Identity indicates the operator identity */
      readonly identity?: string;
      /** @description Batch job ID */
      readonly jobId?: string;
      /**
       * Format: enum
       * @description Batch operation type
       * @enum {string}
       */
      readonly operationType?:
        | 'BATCH_OPERATION_TYPE_UNSPECIFIED'
        | 'BATCH_OPERATION_TYPE_TERMINATE'
        | 'BATCH_OPERATION_TYPE_CANCEL'
        | 'BATCH_OPERATION_TYPE_SIGNAL'
        | 'BATCH_OPERATION_TYPE_DELETE'
        | 'BATCH_OPERATION_TYPE_RESET'
        | 'BATCH_OPERATION_TYPE_UPDATE_EXECUTION_OPTIONS';
      /** @description Reason indicates the reason to stop a operation */
      readonly reason?: string;
      /**
       * Format: date-time
       * @description Batch operation start time
       */
      readonly startTime?: string;
      /**
       * Format: enum
       * @description Batch operation state
       * @enum {string}
       */
      readonly state?:
        | 'BATCH_OPERATION_STATE_UNSPECIFIED'
        | 'BATCH_OPERATION_STATE_RUNNING'
        | 'BATCH_OPERATION_STATE_COMPLETED'
        | 'BATCH_OPERATION_STATE_FAILED';
      /** @description Total operation count */
      readonly totalOperationCount?: string;
    };
    /** @description [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    readonly DescribeDeploymentResponse: {
      readonly deploymentInfo?: components['schemas']['DeploymentInfo'];
    };
    readonly DescribeNamespaceResponse: {
      readonly config?: components['schemas']['NamespaceConfig'];
      /**
       * @description Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
       *  states to ensure that the list does not grow unbounded.
       */
      readonly failoverHistory?: readonly components['schemas']['FailoverStatus'][];
      readonly failoverVersion?: string;
      readonly isGlobalNamespace?: boolean;
      readonly namespaceInfo?: components['schemas']['NamespaceInfo'];
      readonly replicationConfig?: components['schemas']['NamespaceReplicationConfig'];
    };
    readonly DescribeScheduleResponse: {
      /**
       * Format: bytes
       * @description This value can be passed back to UpdateSchedule to ensure that the
       *  schedule was not modified between a Describe and an Update, which could
       *  lead to lost updates and other confusion.
       */
      readonly conflictToken?: string;
      /** @description Extra schedule state info. */
      readonly info?: components['schemas']['ScheduleInfo'];
      /** @description The memo and search attributes that the schedule was created with. */
      readonly memo?: components['schemas']['Memo'];
      /**
       * @description The complete current schedule details. This may not match the schedule as
       *  created because:
       *  - some types of schedule specs may get compiled into others (e.g.
       *    CronString into StructuredCalendarSpec)
       *  - some unspecified fields may be replaced by defaults
       *  - some fields in the state are modified automatically
       *  - the schedule may have been modified by UpdateSchedule or PatchSchedule
       */
      readonly schedule?: components['schemas']['Schedule'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
    };
    readonly DescribeTaskQueueResponse: {
      /**
       * @description Deprecated. Use `versions_info.types_info.pollers` with `ENHANCED` mode instead.
       *  Not set in `ENHANCED` mode.
       */
      readonly pollers?: readonly components['schemas']['PollerInfo'][];
      /** @description Deprecated. Not set in `ENHANCED` mode. */
      readonly taskQueueStatus?: components['schemas']['TaskQueueStatus'];
      /**
       * @description Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.
       *  When not present, it means the tasks are routed to Unversioned workers (workers with
       *  UNVERSIONED or unspecified WorkerVersioningMode.)
       *  Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion
       *  and SetWorkerDeploymentRampingVersion on Worker Deployments.
       *  Note: This information is not relevant to Pinned workflow executions and their activities as
       *  they are always routed to their Pinned Deployment Version. However, new workflow executions
       *  are typically not Pinned until they complete their first task (unless they are started with
       *  a Pinned VersioningOverride or are Child Workflows of a Pinned parent).
       */
      readonly versioningInfo?: components['schemas']['TaskQueueVersioningInfo'];
      /**
       * @description This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
       *  Only set in `ENHANCED` mode.
       */
      readonly versionsInfo?: {
        [key: string]: components['schemas']['TaskQueueVersionInfo'];
      };
    };
    readonly DescribeWorkerDeploymentResponse: {
      /**
       * Format: bytes
       * @description This value is returned so that it can be optionally passed to APIs
       *  that write to the Worker Deployment state to ensure that the state
       *  did not change between this read and a future write.
       */
      readonly conflictToken?: string;
      readonly workerDeploymentInfo?: components['schemas']['WorkerDeploymentInfo'];
    };
    readonly DescribeWorkerDeploymentVersionResponse: {
      readonly workerDeploymentVersionInfo?: components['schemas']['WorkerDeploymentVersionInfo'];
    };
    readonly DescribeWorkflowExecutionResponse: {
      readonly callbacks?: readonly components['schemas']['CallbackInfo'][];
      readonly executionConfig?: components['schemas']['WorkflowExecutionConfig'];
      readonly pendingActivities?: readonly components['schemas']['PendingActivityInfo'][];
      readonly pendingChildren?: readonly components['schemas']['PendingChildExecutionInfo'][];
      readonly pendingNexusOperations?: readonly components['schemas']['PendingNexusOperationInfo'][];
      readonly pendingWorkflowTask?: components['schemas']['PendingWorkflowTaskInfo'];
      readonly workflowExecutionInfo?: components['schemas']['WorkflowExecutionInfo'];
      readonly workflowExtendedInfo?: components['schemas']['WorkflowExecutionExtendedInfo'];
    };
    readonly DescribeWorkflowRuleResponse: {
      /** @description The rule that was read. */
      readonly rule?: components['schemas']['WorkflowRule'];
    };
    /** @description A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests. */
    readonly Endpoint: {
      /**
       * Format: date-time
       * @description The date and time when the endpoint was created.
       *  (-- api-linter: core::0142::time-field-names=disabled
       *      aip.dev/not-precedent: Not following linter rules. --)
       */
      readonly createdTime?: string;
      /** @description Unique server-generated endpoint ID. */
      readonly id?: string;
      /**
       * Format: date-time
       * @description The date and time when the endpoint was last modified.
       *  Will not be set if the endpoint has never been modified.
       *  (-- api-linter: core::0142::time-field-names=disabled
       *      aip.dev/not-precedent: Not following linter rules. --)
       */
      readonly lastModifiedTime?: string;
      /** @description Spec for the endpoint. */
      readonly spec?: components['schemas']['EndpointSpec'];
      /**
       * @description Server exposed URL prefix for invocation of operations on this endpoint.
       *  This doesn't include the protocol, hostname or port as the server does not know how it should be accessed
       *  publicly. The URL is stable in the face of endpoint renames.
       */
      readonly urlPrefix?: string;
      /** @description Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API. */
      readonly version?: string;
    };
    /** @description Contains mutable fields for an Endpoint. */
    readonly EndpointSpec: {
      /**
       * @description Markdown description serialized as a single JSON string.
       *  If the Payload is encrypted, the UI and CLI may decrypt with the configured codec server endpoint.
       *  By default, the server enforces a limit of 20,000 bytes for this entire payload.
       */
      readonly description?: components['schemas']['Payload'];
      /**
       * @description Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.
       *  Renaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail.
       */
      readonly name?: string;
      /** @description Target to route requests to. */
      readonly target?: components['schemas']['EndpointTarget'];
    };
    /** @description Target to route requests to. */
    readonly EndpointTarget: {
      readonly external?: components['schemas']['EndpointTarget_External'];
      readonly worker?: components['schemas']['EndpointTarget_Worker'];
    };
    /**
     * @description Target an external server by URL.
     *  At a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected
     *  into the server to modify the request.
     */
    readonly EndpointTarget_External: {
      /** @description URL to call. */
      readonly url?: string;
    };
    /** @description Target a worker polling on a Nexus task queue in a specific namespace. */
    readonly EndpointTarget_Worker: {
      /** @description Namespace to route requests to. */
      readonly namespace?: string;
      /** @description Nexus task queue to route requests to. */
      readonly taskQueue?: string;
    };
    readonly ExecuteMultiOperationRequest: {
      readonly namespace?: string;
      /**
       * @description List of operations to execute within a single workflow.
       *
       *  Preconditions:
       *  - The list of operations must not be empty.
       *  - The workflow ids must match across operations.
       *  - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
       *
       *  Note that additional operation-specific restrictions have to be considered.
       */
      readonly operations?: readonly components['schemas']['ExecuteMultiOperationRequest_Operation'][];
    };
    readonly ExecuteMultiOperationRequest_Operation: {
      /**
       * @description Additional restrictions:
       *  - setting `cron_schedule` is invalid
       *  - setting `request_eager_execution` is invalid
       *  - setting `workflow_start_delay` is invalid
       */
      readonly startWorkflow?: components['schemas']['StartWorkflowExecutionRequest'];
      /**
       * @description Additional restrictions:
       *  - setting `first_execution_run_id` is invalid
       *  - setting `workflow_execution.run_id` is invalid
       */
      readonly updateWorkflow?: components['schemas']['UpdateWorkflowExecutionRequest'];
    };
    readonly ExecuteMultiOperationResponse: {
      readonly responses?: readonly components['schemas']['ExecuteMultiOperationResponse_Response'][];
    };
    readonly ExecuteMultiOperationResponse_Response: {
      readonly startWorkflow?: components['schemas']['StartWorkflowExecutionResponse'];
      readonly updateWorkflow?: components['schemas']['UpdateWorkflowExecutionResponse'];
    };
    readonly ExternalWorkflowExecutionCancelRequestedEventAttributes: {
      /**
       * @description id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds
       *  to
       */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the to-be-cancelled workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    readonly ExternalWorkflowExecutionSignaledEventAttributes: {
      /** @description Deprecated */
      readonly control?: string;
      /** @description id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the workflow which was signaled.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    /** @description Represents a historical replication status of a Namespace */
    readonly FailoverStatus: {
      /**
       * Format: date-time
       * @description Timestamp when the Cluster switched to the following failover_version
       */
      readonly failoverTime?: string;
      readonly failoverVersion?: string;
    };
    readonly Failure: {
      readonly activityFailureInfo?: components['schemas']['ActivityFailureInfo'];
      readonly applicationFailureInfo?: components['schemas']['ApplicationFailureInfo'];
      readonly canceledFailureInfo?: components['schemas']['CanceledFailureInfo'];
      readonly cause?: components['schemas']['Failure'];
      readonly childWorkflowExecutionFailureInfo?: components['schemas']['ChildWorkflowExecutionFailureInfo'];
      /**
       * @description Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
       *  errors originating in user code which might contain sensitive information.
       *  The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
       *  message.
       *
       *  SDK authors:
       *  - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
       *    - Uses a JSON object to represent `{ message, stack_trace }`.
       *    - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
       *    - Overwrites the original stack_trace with an empty string.
       *    - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
       *      by the user-provided PayloadCodec
       *
       *  - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
       */
      readonly encodedAttributes?: components['schemas']['Payload'];
      readonly message?: string;
      readonly nexusHandlerFailureInfo?: components['schemas']['NexusHandlerFailureInfo'];
      readonly nexusOperationExecutionFailureInfo?: components['schemas']['NexusOperationFailureInfo'];
      readonly resetWorkflowFailureInfo?: components['schemas']['ResetWorkflowFailureInfo'];
      readonly serverFailureInfo?: components['schemas']['ServerFailureInfo'];
      /**
       * @description The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
       *  In some SDKs this is used to rehydrate the stack trace into an exception object.
       */
      readonly source?: string;
      readonly stackTrace?: string;
      readonly terminatedFailureInfo?: components['schemas']['TerminatedFailureInfo'];
      readonly timeoutFailureInfo?: components['schemas']['TimeoutFailureInfo'];
    };
    /** @description GetClusterInfoResponse contains information about Temporal cluster. */
    readonly GetClusterInfoResponse: {
      readonly clusterId?: string;
      readonly clusterName?: string;
      /** Format: int32 */
      readonly historyShardCount?: number;
      readonly persistenceStore?: string;
      readonly serverVersion?: string;
      /**
       * @description Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
       *  Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
       */
      readonly supportedClients?: {
        [key: string]: string;
      };
      readonly versionInfo?: components['schemas']['VersionInfo'];
      readonly visibilityStore?: string;
    };
    /** @description [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    readonly GetCurrentDeploymentResponse: {
      readonly currentDeploymentInfo?: components['schemas']['DeploymentInfo'];
    };
    /** @description [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    readonly GetDeploymentReachabilityResponse: {
      readonly deploymentInfo?: components['schemas']['DeploymentInfo'];
      /**
       * Format: date-time
       * @description Reachability level might come from server cache. This timestamp specifies when the value
       *  was actually calculated.
       */
      readonly lastUpdateTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly reachability?:
        | 'DEPLOYMENT_REACHABILITY_UNSPECIFIED'
        | 'DEPLOYMENT_REACHABILITY_REACHABLE'
        | 'DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY'
        | 'DEPLOYMENT_REACHABILITY_UNREACHABLE';
    };
    readonly GetNexusEndpointResponse: {
      readonly endpoint?: components['schemas']['Endpoint'];
    };
    readonly GetSystemInfoResponse: {
      /** @description All capabilities the system supports. */
      readonly capabilities?: components['schemas']['GetSystemInfoResponse_Capabilities'];
      /** @description Version of the server. */
      readonly serverVersion?: string;
    };
    /** @description System capability details. */
    readonly GetSystemInfoResponse_Capabilities: {
      /** @description True if RespondActivityTaskFailed API supports including heartbeat details */
      readonly activityFailureIncludeHeartbeat?: boolean;
      /**
       * @description True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
       *  (see:
       *  https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
       */
      readonly buildIdBasedVersioning?: boolean;
      /** @description True if the server supports count group by execution status */
      readonly countGroupByExecutionStatus?: boolean;
      /** @description True if server supports eager workflow task dispatching for the StartWorkflowExecution API */
      readonly eagerWorkflowStart?: boolean;
      /** @description True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes */
      readonly encodedFailureAttributes?: boolean;
      /**
       * @description True if internal errors are differentiated from other types of errors for purposes of
       *  retrying non-internal errors.
       *
       *  When unset/false, clients retry all failures. When true, clients should only retry
       *  non-internal errors.
       */
      readonly internalErrorDifferentiation?: boolean;
      /**
       * @description True if the server supports Nexus operations.
       *  This flag is dependent both on server version and for Nexus to be enabled via server configuration.
       */
      readonly nexus?: boolean;
      /**
       * @description True if the server knows about the sdk metadata field on WFT completions and will record
       *  it in history
       */
      readonly sdkMetadata?: boolean;
      /** @description True if signal and query headers are supported. */
      readonly signalAndQueryHeader?: boolean;
      /** @description Supports scheduled workflow features. */
      readonly supportsSchedules?: boolean;
      /** @description True if server supports upserting workflow memo */
      readonly upsertMemo?: boolean;
    };
    /** @description [cleanup-wv-pre-release] */
    readonly GetWorkerBuildIdCompatibilityResponse: {
      /**
       * @description Major version sets, in order from oldest to newest. The last element of the list will always
       *  be the current default major version. IE: New workflows will target the most recent version
       *  in that version set.
       *
       *  There may be fewer sets returned than exist, if the request chose to limit this response.
       */
      readonly majorVersionSets?: readonly components['schemas']['CompatibleVersionSet'][];
    };
    /**
     * @description [cleanup-wv-pre-release]
     *  Deprecated. Use `DescribeTaskQueue`.
     */
    readonly GetWorkerTaskReachabilityResponse: {
      /**
       * @description Task reachability, broken down by build id and then task queue.
       *  When requesting a large number of task queues or all task queues associated with the given build ids in a
       *  namespace, all task queues will be listed in the response but some of them may not contain reachability
       *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
       *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
       *  another call to get the reachability for those task queues.
       *
       *  Open source users can adjust this limit by setting the server's dynamic config value for
       *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
       */
      readonly buildIdReachability?: readonly components['schemas']['BuildIdReachability'][];
    };
    /** @description [cleanup-wv-pre-release] */
    readonly GetWorkerVersioningRulesResponse: {
      readonly assignmentRules?: readonly components['schemas']['TimestampedBuildIdAssignmentRule'][];
      readonly compatibleRedirectRules?: readonly components['schemas']['TimestampedCompatibleBuildIdRedirectRule'][];
      /**
       * Format: bytes
       * @description This value can be passed back to UpdateWorkerVersioningRulesRequest to
       *  ensure that the rules were not modified between this List and the Update,
       *  which could lead to lost updates and other confusion.
       */
      readonly conflictToken?: string;
    };
    readonly GetWorkflowExecutionHistoryResponse: {
      readonly archived?: boolean;
      readonly history?: components['schemas']['History'];
      /**
       * Format: bytes
       * @description Will be set if there are more history events than were included in this response
       */
      readonly nextPageToken?: string;
      /**
       * @description Raw history is an alternate representation of history that may be returned if configured on
       *  the frontend. This is not supported by all SDKs. Either this or `history` will be set.
       */
      readonly rawHistory?: readonly components['schemas']['DataBlob'][];
    };
    readonly GetWorkflowExecutionHistoryReverseResponse: {
      readonly history?: components['schemas']['History'];
      /**
       * Format: bytes
       * @description Will be set if there are more history events than were included in this response
       */
      readonly nextPageToken?: string;
    };
    /** @description Contains an arbitrary serialized message along with a @type that describes the type of the serialized message. */
    readonly GoogleProtobufAny: {
      /** @description The type of the serialized message. */
      readonly '@type'?: string;
      [key: string]: unknown;
    };
    /**
     * @description Contains metadata that can be attached to a variety of requests, like starting a workflow, and
     *  can be propagated between, for example, workflows and activities.
     */
    readonly Header: {
      readonly fields?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    readonly History: {
      readonly events?: readonly components['schemas']['HistoryEvent'][];
    };
    /**
     * @description History events are the method by which Temporal SDKs advance (or recreate) workflow state.
     *  See the `EventType` enum for more info about what each event is for.
     */
    readonly HistoryEvent: {
      readonly activityPropertiesModifiedExternallyEventAttributes?: components['schemas']['ActivityPropertiesModifiedExternallyEventAttributes'];
      readonly activityTaskCanceledEventAttributes?: components['schemas']['ActivityTaskCanceledEventAttributes'];
      readonly activityTaskCancelRequestedEventAttributes?: components['schemas']['ActivityTaskCancelRequestedEventAttributes'];
      readonly activityTaskCompletedEventAttributes?: components['schemas']['ActivityTaskCompletedEventAttributes'];
      readonly activityTaskFailedEventAttributes?: components['schemas']['ActivityTaskFailedEventAttributes'];
      readonly activityTaskScheduledEventAttributes?: components['schemas']['ActivityTaskScheduledEventAttributes'];
      readonly activityTaskStartedEventAttributes?: components['schemas']['ActivityTaskStartedEventAttributes'];
      readonly activityTaskTimedOutEventAttributes?: components['schemas']['ActivityTaskTimedOutEventAttributes'];
      readonly childWorkflowExecutionCanceledEventAttributes?: components['schemas']['ChildWorkflowExecutionCanceledEventAttributes'];
      readonly childWorkflowExecutionCompletedEventAttributes?: components['schemas']['ChildWorkflowExecutionCompletedEventAttributes'];
      readonly childWorkflowExecutionFailedEventAttributes?: components['schemas']['ChildWorkflowExecutionFailedEventAttributes'];
      readonly childWorkflowExecutionStartedEventAttributes?: components['schemas']['ChildWorkflowExecutionStartedEventAttributes'];
      readonly childWorkflowExecutionTerminatedEventAttributes?: components['schemas']['ChildWorkflowExecutionTerminatedEventAttributes'];
      readonly childWorkflowExecutionTimedOutEventAttributes?: components['schemas']['ChildWorkflowExecutionTimedOutEventAttributes'];
      /** @description Monotonically increasing event number, starts at 1. */
      readonly eventId?: string;
      /** Format: date-time */
      readonly eventTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly eventType?:
        | 'EVENT_TYPE_UNSPECIFIED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_STARTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT'
        | 'EVENT_TYPE_WORKFLOW_TASK_SCHEDULED'
        | 'EVENT_TYPE_WORKFLOW_TASK_STARTED'
        | 'EVENT_TYPE_WORKFLOW_TASK_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT'
        | 'EVENT_TYPE_WORKFLOW_TASK_FAILED'
        | 'EVENT_TYPE_ACTIVITY_TASK_SCHEDULED'
        | 'EVENT_TYPE_ACTIVITY_TASK_STARTED'
        | 'EVENT_TYPE_ACTIVITY_TASK_COMPLETED'
        | 'EVENT_TYPE_ACTIVITY_TASK_FAILED'
        | 'EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT'
        | 'EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED'
        | 'EVENT_TYPE_ACTIVITY_TASK_CANCELED'
        | 'EVENT_TYPE_TIMER_STARTED'
        | 'EVENT_TYPE_TIMER_FIRED'
        | 'EVENT_TYPE_TIMER_CANCELED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED'
        | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_MARKER_RECORDED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW'
        | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED'
        | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED'
        | 'EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY'
        | 'EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY'
        | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED'
        | 'EVENT_TYPE_NEXUS_OPERATION_SCHEDULED'
        | 'EVENT_TYPE_NEXUS_OPERATION_STARTED'
        | 'EVENT_TYPE_NEXUS_OPERATION_COMPLETED'
        | 'EVENT_TYPE_NEXUS_OPERATION_FAILED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCELED'
        | 'EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED';
      readonly externalWorkflowExecutionCancelRequestedEventAttributes?: components['schemas']['ExternalWorkflowExecutionCancelRequestedEventAttributes'];
      readonly externalWorkflowExecutionSignaledEventAttributes?: components['schemas']['ExternalWorkflowExecutionSignaledEventAttributes'];
      /** @description Links associated with the event. */
      readonly links?: readonly components['schemas']['Link'][];
      readonly markerRecordedEventAttributes?: components['schemas']['MarkerRecordedEventAttributes'];
      readonly nexusOperationCanceledEventAttributes?: components['schemas']['NexusOperationCanceledEventAttributes'];
      readonly nexusOperationCancelRequestCompletedEventAttributes?: components['schemas']['NexusOperationCancelRequestCompletedEventAttributes'];
      readonly nexusOperationCancelRequestedEventAttributes?: components['schemas']['NexusOperationCancelRequestedEventAttributes'];
      readonly nexusOperationCancelRequestFailedEventAttributes?: components['schemas']['NexusOperationCancelRequestFailedEventAttributes'];
      readonly nexusOperationCompletedEventAttributes?: components['schemas']['NexusOperationCompletedEventAttributes'];
      readonly nexusOperationFailedEventAttributes?: components['schemas']['NexusOperationFailedEventAttributes'];
      readonly nexusOperationScheduledEventAttributes?: components['schemas']['NexusOperationScheduledEventAttributes'];
      readonly nexusOperationStartedEventAttributes?: components['schemas']['NexusOperationStartedEventAttributes'];
      readonly nexusOperationTimedOutEventAttributes?: components['schemas']['NexusOperationTimedOutEventAttributes'];
      readonly requestCancelExternalWorkflowExecutionFailedEventAttributes?: components['schemas']['RequestCancelExternalWorkflowExecutionFailedEventAttributes'];
      readonly requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: components['schemas']['RequestCancelExternalWorkflowExecutionInitiatedEventAttributes'];
      readonly signalExternalWorkflowExecutionFailedEventAttributes?: components['schemas']['SignalExternalWorkflowExecutionFailedEventAttributes'];
      readonly signalExternalWorkflowExecutionInitiatedEventAttributes?: components['schemas']['SignalExternalWorkflowExecutionInitiatedEventAttributes'];
      readonly startChildWorkflowExecutionFailedEventAttributes?: components['schemas']['StartChildWorkflowExecutionFailedEventAttributes'];
      readonly startChildWorkflowExecutionInitiatedEventAttributes?: components['schemas']['StartChildWorkflowExecutionInitiatedEventAttributes'];
      /** @description TODO: What is this? Appears unused by SDKs */
      readonly taskId?: string;
      readonly timerCanceledEventAttributes?: components['schemas']['TimerCanceledEventAttributes'];
      readonly timerFiredEventAttributes?: components['schemas']['TimerFiredEventAttributes'];
      readonly timerStartedEventAttributes?: components['schemas']['TimerStartedEventAttributes'];
      readonly upsertWorkflowSearchAttributesEventAttributes?: components['schemas']['UpsertWorkflowSearchAttributesEventAttributes'];
      /**
       * @description Metadata on the event. This is often carried over from commands and client calls. Most events
       *  won't have this information, and how this information is used is dependent upon the interface
       *  that reads it.
       *
       *  Current well-known uses:
       *   * workflow_execution_started_event_attributes - summary and details from start workflow.
       *   * timer_started_event_attributes - summary represents an identifier for the timer for use by
       *     user interfaces.
       */
      readonly userMetadata?: components['schemas']['UserMetadata'];
      /** @description TODO: What is this? Appears unused by SDKs */
      readonly version?: string;
      /**
       * @description Set to true when the SDK may ignore the event as it does not impact workflow state or
       *  information in any way that the SDK need be concerned with. If an SDK encounters an event
       *  type which it does not understand, it must error unless this is true. If it is true, it's
       *  acceptable for the event type and/or attributes to be uninterpretable.
       */
      readonly workerMayIgnore?: boolean;
      readonly workflowExecutionCanceledEventAttributes?: components['schemas']['WorkflowExecutionCanceledEventAttributes'];
      readonly workflowExecutionCancelRequestedEventAttributes?: components['schemas']['WorkflowExecutionCancelRequestedEventAttributes'];
      readonly workflowExecutionCompletedEventAttributes?: components['schemas']['WorkflowExecutionCompletedEventAttributes'];
      readonly workflowExecutionContinuedAsNewEventAttributes?: components['schemas']['WorkflowExecutionContinuedAsNewEventAttributes'];
      readonly workflowExecutionFailedEventAttributes?: components['schemas']['WorkflowExecutionFailedEventAttributes'];
      readonly workflowExecutionOptionsUpdatedEventAttributes?: components['schemas']['WorkflowExecutionOptionsUpdatedEventAttributes'];
      readonly workflowExecutionSignaledEventAttributes?: components['schemas']['WorkflowExecutionSignaledEventAttributes'];
      readonly workflowExecutionStartedEventAttributes?: components['schemas']['WorkflowExecutionStartedEventAttributes'];
      readonly workflowExecutionTerminatedEventAttributes?: components['schemas']['WorkflowExecutionTerminatedEventAttributes'];
      readonly workflowExecutionTimedOutEventAttributes?: components['schemas']['WorkflowExecutionTimedOutEventAttributes'];
      readonly workflowExecutionUpdateAcceptedEventAttributes?: components['schemas']['WorkflowExecutionUpdateAcceptedEventAttributes'];
      readonly workflowExecutionUpdateAdmittedEventAttributes?: components['schemas']['WorkflowExecutionUpdateAdmittedEventAttributes'];
      readonly workflowExecutionUpdateCompletedEventAttributes?: components['schemas']['WorkflowExecutionUpdateCompletedEventAttributes'];
      readonly workflowExecutionUpdateRejectedEventAttributes?: components['schemas']['WorkflowExecutionUpdateRejectedEventAttributes'];
      readonly workflowPropertiesModifiedEventAttributes?: components['schemas']['WorkflowPropertiesModifiedEventAttributes'];
      readonly workflowPropertiesModifiedExternallyEventAttributes?: components['schemas']['WorkflowPropertiesModifiedExternallyEventAttributes'];
      readonly workflowTaskCompletedEventAttributes?: components['schemas']['WorkflowTaskCompletedEventAttributes'];
      readonly workflowTaskFailedEventAttributes?: components['schemas']['WorkflowTaskFailedEventAttributes'];
      readonly workflowTaskScheduledEventAttributes?: components['schemas']['WorkflowTaskScheduledEventAttributes'];
      readonly workflowTaskStartedEventAttributes?: components['schemas']['WorkflowTaskStartedEventAttributes'];
      readonly workflowTaskTimedOutEventAttributes?: components['schemas']['WorkflowTaskTimedOutEventAttributes'];
    };
    readonly Input: {
      /** @description The arguments to pass to the named Update handler. */
      readonly args?: components['schemas']['Payloads'];
      /**
       * @description Headers that are passed with the Update from the requesting entity.
       *  These can include things like auth or tracing tokens.
       */
      readonly header?: components['schemas']['Header'];
      /** @description The name of the Update handler to invoke on the target Workflow. */
      readonly name?: string;
    };
    /**
     * @description IntervalSpec matches times that can be expressed as:
     *  epoch + n * interval + phase
     *  where n is an integer.
     *  phase defaults to zero if missing. interval is required.
     *  Both interval and phase must be non-negative and are truncated to the nearest
     *  second before any calculations.
     *  For example, an interval of 1 hour with phase of zero would match every hour,
     *  on the hour. The same interval but a phase of 19 minutes would match every
     *  xx:19:00. An interval of 28 days with phase zero would match
     *  2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
     *  days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
     */
    readonly IntervalSpec: {
      readonly interval?: string;
      readonly phase?: string;
    };
    /**
     * @description Link can be associated with history events. It might contain information about an external entity
     *  related to the history event. For example, workflow A makes a Nexus call that starts workflow B:
     *  in this case, a history event in workflow A could contain a Link to the workflow started event in
     *  workflow B, and vice-versa.
     */
    readonly Link: {
      readonly batchJob?: components['schemas']['Link_BatchJob'];
      readonly workflowEvent?: components['schemas']['Link_WorkflowEvent'];
    };
    /**
     * @description A link to a built-in batch job.
     *  Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).
     *  This link can be put on workflow history events generated by actions taken by a batch job.
     */
    readonly Link_BatchJob: {
      readonly jobId?: string;
    };
    readonly Link_WorkflowEvent: {
      readonly eventRef?: components['schemas']['WorkflowEvent_EventReference'];
      readonly namespace?: string;
      readonly runId?: string;
      readonly workflowId?: string;
    };
    readonly ListArchivedWorkflowExecutionsResponse: {
      readonly executions?: readonly components['schemas']['WorkflowExecutionInfo'][];
      /** Format: bytes */
      readonly nextPageToken?: string;
    };
    readonly ListBatchOperationsResponse: {
      /** Format: bytes */
      readonly nextPageToken?: string;
      /** @description BatchOperationInfo contains the basic info about batch operation */
      readonly operationInfo?: readonly components['schemas']['BatchOperationInfo'][];
    };
    /** @description [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    readonly ListDeploymentsResponse: {
      readonly deployments?: readonly components['schemas']['DeploymentListInfo'][];
      /** Format: bytes */
      readonly nextPageToken?: string;
    };
    readonly ListNamespacesResponse: {
      readonly namespaces?: readonly components['schemas']['DescribeNamespaceResponse'][];
      /** Format: bytes */
      readonly nextPageToken?: string;
    };
    readonly ListNexusEndpointsResponse: {
      readonly endpoints?: readonly components['schemas']['Endpoint'][];
      /**
       * Format: bytes
       * @description Token for getting the next page.
       */
      readonly nextPageToken?: string;
    };
    readonly ListScheduleMatchingTimesResponse: {
      readonly startTime?: readonly string[];
    };
    readonly ListSchedulesResponse: {
      /** Format: bytes */
      readonly nextPageToken?: string;
      readonly schedules?: readonly components['schemas']['ScheduleListEntry'][];
    };
    readonly ListSearchAttributesResponse: {
      /** @description Mapping between custom (user-registered) search attribute name to its IndexedValueType. */
      readonly customAttributes?: {
        [key: string]:
          | 'INDEXED_VALUE_TYPE_UNSPECIFIED'
          | 'INDEXED_VALUE_TYPE_TEXT'
          | 'INDEXED_VALUE_TYPE_KEYWORD'
          | 'INDEXED_VALUE_TYPE_INT'
          | 'INDEXED_VALUE_TYPE_DOUBLE'
          | 'INDEXED_VALUE_TYPE_BOOL'
          | 'INDEXED_VALUE_TYPE_DATETIME'
          | 'INDEXED_VALUE_TYPE_KEYWORD_LIST';
      };
      /** @description Mapping from the attribute name to the visibility storage native type. */
      readonly storageSchema?: {
        [key: string]: string;
      };
      /** @description Mapping between system (predefined) search attribute name to its IndexedValueType. */
      readonly systemAttributes?: {
        [key: string]:
          | 'INDEXED_VALUE_TYPE_UNSPECIFIED'
          | 'INDEXED_VALUE_TYPE_TEXT'
          | 'INDEXED_VALUE_TYPE_KEYWORD'
          | 'INDEXED_VALUE_TYPE_INT'
          | 'INDEXED_VALUE_TYPE_DOUBLE'
          | 'INDEXED_VALUE_TYPE_BOOL'
          | 'INDEXED_VALUE_TYPE_DATETIME'
          | 'INDEXED_VALUE_TYPE_KEYWORD_LIST';
      };
    };
    readonly ListWorkerDeploymentsResponse: {
      /** Format: bytes */
      readonly nextPageToken?: string;
      /** @description The list of worker deployments. */
      readonly workerDeployments?: readonly components['schemas']['ListWorkerDeploymentsResponse_WorkerDeploymentSummary'][];
    };
    /** @description A subset of WorkerDeploymentInfo */
    readonly ListWorkerDeploymentsResponse_WorkerDeploymentSummary: {
      /** Format: date-time */
      readonly createTime?: string;
      readonly name?: string;
      readonly routingConfig?: components['schemas']['RoutingConfig'];
    };
    readonly ListWorkflowExecutionsResponse: {
      readonly executions?: readonly components['schemas']['WorkflowExecutionInfo'][];
      /** Format: bytes */
      readonly nextPageToken?: string;
    };
    readonly ListWorkflowRulesResponse: {
      /** Format: bytes */
      readonly nextPageToken?: string;
      readonly rules?: readonly components['schemas']['WorkflowRule'][];
    };
    readonly MarkerRecordedEventAttributes: {
      /** @description Serialized information recorded in the marker */
      readonly details?: {
        [key: string]: components['schemas']['Payloads'];
      };
      /** @description Some uses of markers, like a local activity, could "fail". If they did that is recorded here. */
      readonly failure?: components['schemas']['Failure'];
      readonly header?: components['schemas']['Header'];
      /** @description Workers use this to identify the "types" of various markers. Ex: Local activity, side effect. */
      readonly markerName?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    /** @description A user-defined set of *unindexed* fields that are exposed when listing/searching workflows */
    readonly Memo: {
      readonly fields?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    /**
     * @description (-- api-linter: core::0146::any=disabled
     *      aip.dev/not-precedent: We want runtime extensibility for the body field --)
     */
    readonly Message: {
      /**
       * @description The opaque data carried by this message. The protocol type can be
       *  extracted from the package name of the message carried inside the Any.
       */
      readonly body?: components['schemas']['GoogleProtobufAny'];
      readonly commandIndex?: string;
      readonly eventId?: string;
      /** @description An ID for this specific message. */
      readonly id?: string;
      /**
       * @description Identifies the specific instance of a protocol to which this message
       *  belongs.
       */
      readonly protocolInstanceId?: string;
    };
    /** @description Metadata about a Workflow Update. */
    readonly Meta: {
      /** @description A string identifying the agent that requested this Update. */
      readonly identity?: string;
      /** @description An ID with workflow-scoped uniqueness for this Update. */
      readonly updateId?: string;
    };
    /** @description Metadata relevant for metering purposes */
    readonly MeteringMetadata: {
      /**
       * Format: uint32
       * @description Count of local activities which have begun an execution attempt during this workflow task,
       *  and whose first attempt occurred in some previous task. This is used for metering
       *  purposes, and does not affect workflow state.
       *
       *  (-- api-linter: core::0141::forbidden-types=disabled
       *      aip.dev/not-precedent: Negative values make no sense to represent. --)
       */
      readonly nonfirstLocalActivityExecutionAttempts?: number;
    };
    readonly NamespaceConfig: {
      readonly badBinaries?: components['schemas']['BadBinaries'];
      /** @description Map from field name to alias. */
      readonly customSearchAttributeAliases?: {
        [key: string]: string;
      };
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      readonly historyArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      readonly historyArchivalUri?: string;
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      readonly visibilityArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      readonly visibilityArchivalUri?: string;
      readonly workflowExecutionRetentionTtl?: string;
    };
    readonly NamespaceInfo: {
      /** @description All capabilities the namespace supports. */
      readonly capabilities?: components['schemas']['NamespaceInfo_Capabilities'];
      /** @description A key-value map for any customized purpose. */
      readonly data?: {
        [key: string]: string;
      };
      readonly description?: string;
      readonly id?: string;
      readonly name?: string;
      readonly ownerEmail?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'NAMESPACE_STATE_UNSPECIFIED'
        | 'NAMESPACE_STATE_REGISTERED'
        | 'NAMESPACE_STATE_DEPRECATED'
        | 'NAMESPACE_STATE_DELETED';
      /**
       * @description Whether scheduled workflows are supported on this namespace. This is only needed
       *  temporarily while the feature is experimental, so we can give it a high tag.
       */
      readonly supportsSchedules?: boolean;
    };
    /** @description Namespace capability details. Should contain what features are enabled in a namespace. */
    readonly NamespaceInfo_Capabilities: {
      /** @description True if the namespace supports async update */
      readonly asyncUpdate?: boolean;
      /** @description True if the namespace supports eager workflow start. */
      readonly eagerWorkflowStart?: boolean;
      /** @description True if the namespace supports sync update */
      readonly syncUpdate?: boolean;
    };
    readonly NamespaceReplicationConfig: {
      readonly activeClusterName?: string;
      readonly clusters?: readonly components['schemas']['ClusterReplicationConfig'][];
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'REPLICATION_STATE_UNSPECIFIED'
        | 'REPLICATION_STATE_NORMAL'
        | 'REPLICATION_STATE_HANDOVER';
    };
    /**
     * @description NewWorkflowExecutionInfo is a shared message that encapsulates all the
     *  required arguments to starting a workflow in different contexts.
     */
    readonly NewWorkflowExecutionInfo: {
      /** @description See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      readonly cronSchedule?: string;
      readonly header?: components['schemas']['Header'];
      /** @description Serialized arguments to the workflow. */
      readonly input?: components['schemas']['Payloads'];
      readonly memo?: components['schemas']['Memo'];
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      /** @description The retry policy for the workflow. Will never exceed `workflow_execution_timeout`. */
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /**
       * @description Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
       *  for use by user interfaces to display the fixed as-of-start summary and details of the
       *  workflow.
       */
      readonly userMetadata?: components['schemas']['UserMetadata'];
      /**
       * @description If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
       *  To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
       */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      readonly workflowExecutionTimeout?: string;
      readonly workflowId?: string;
      /**
       * Format: enum
       * @description Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       * @enum {string}
       */
      readonly workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /** @description Timeout of a single workflow run. */
      readonly workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      readonly workflowTaskTimeout?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly NexusHandlerFailureInfo: {
      /**
       * Format: enum
       * @description Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
       * @enum {string}
       */
      readonly retryBehavior?:
        | 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED'
        | 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE'
        | 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE';
      /**
       * @description The Nexus error type as defined in the spec:
       *  https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
       */
      readonly type?: string;
    };
    /** @description Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow. */
    readonly NexusOperationCanceledEventAttributes: {
      /** @description Cancellation details. */
      readonly failure?: components['schemas']['Failure'];
      /** @description The request ID allocated at schedule time. */
      readonly requestId?: string;
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      readonly scheduledEventId?: string;
    };
    /** @description NexusOperationCancellationInfo contains the state of a nexus operation cancellation. */
    readonly NexusOperationCancellationInfo: {
      /**
       * Format: int32
       * @description The number of attempts made to deliver the cancel operation request.
       *  This number represents a minimum bound since the attempt is incremented after the request completes.
       */
      readonly attempt?: number;
      /** @description If the state is BLOCKED, blocked reason provides additional information. */
      readonly blockedReason?: string;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      readonly lastAttemptCompleteTime?: string;
      /** @description The last attempt's failure, if any. */
      readonly lastAttemptFailure?: components['schemas']['Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      readonly nextAttemptScheduleTime?: string;
      /**
       * Format: date-time
       * @description The time when cancellation was requested.
       */
      readonly requestedTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_FAILED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED';
    };
    readonly NexusOperationCancelRequestCompletedEventAttributes: {
      /** @description The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event. */
      readonly requestedEventId?: string;
      /**
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *  with.
       */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly NexusOperationCancelRequestedEventAttributes: {
      /** @description The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to. */
      readonly scheduledEventId?: string;
      /**
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *  with.
       */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly NexusOperationCancelRequestFailedEventAttributes: {
      /** @description Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo. */
      readonly failure?: components['schemas']['Failure'];
      /** @description The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event. */
      readonly requestedEventId?: string;
      /**
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *  with.
       */
      readonly workflowTaskCompletedEventId?: string;
    };
    /** @description Nexus operation completed successfully. */
    readonly NexusOperationCompletedEventAttributes: {
      /** @description The request ID allocated at schedule time. */
      readonly requestId?: string;
      /**
       * @description Serialized result of the Nexus operation. The response of the Nexus handler.
       *  Delivered either via a completion callback or as a response to a synchronous operation.
       */
      readonly result?: components['schemas']['Payload'];
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      readonly scheduledEventId?: string;
    };
    /** @description Nexus operation failed. */
    readonly NexusOperationFailedEventAttributes: {
      /** @description Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo. */
      readonly failure?: components['schemas']['Failure'];
      /** @description The request ID allocated at schedule time. */
      readonly requestId?: string;
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      readonly scheduledEventId?: string;
    };
    readonly NexusOperationFailureInfo: {
      /** @description Endpoint name. */
      readonly endpoint?: string;
      /** @description Operation name. */
      readonly operation?: string;
      /**
       * @description Operation ID - may be empty if the operation completed synchronously.
       *
       *  Deprecated: Renamed to operation_token.
       */
      readonly operationId?: string;
      /** @description Operation token - may be empty if the operation completed synchronously. */
      readonly operationToken?: string;
      /** @description The NexusOperationScheduled event ID. */
      readonly scheduledEventId?: string;
      /** @description Service name. */
      readonly service?: string;
    };
    /** @description Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command. */
    readonly NexusOperationScheduledEventAttributes: {
      /** @description Endpoint name, must exist in the endpoint registry. */
      readonly endpoint?: string;
      /**
       * @description Endpoint ID as resolved in the endpoint registry at the time this event was generated.
       *  This is stored on the event and used internally by the server in case the endpoint is renamed from the time the
       *  event was originally scheduled.
       */
      readonly endpointId?: string;
      /**
       * @description Input for the operation. The server converts this into Nexus request content and the appropriate content headers
       *  internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
       *  content is transformed back to the original Payload stored in this event.
       */
      readonly input?: components['schemas']['Payload'];
      /**
       * @description Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal
       *  activities and child workflows, these are transmitted to Nexus operations that may be external and are not
       *  traditional payloads.
       */
      readonly nexusHeader?: {
        [key: string]: string;
      };
      /** @description Operation name. */
      readonly operation?: string;
      /**
       * @description A unique ID generated by the history service upon creation of this event.
       *  The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key.
       */
      readonly requestId?: string;
      /**
       * @description Schedule-to-close timeout for this operation.
       *  Indicates how long the caller is willing to wait for operation completion.
       *  Calls are retried internally by the server.
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly scheduleToCloseTimeout?: string;
      /** @description Service name. */
      readonly service?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with. */
      readonly workflowTaskCompletedEventId?: string;
    };
    /**
     * @description Event marking an asynchronous operation was started by the responding Nexus handler.
     *  If the operation completes synchronously, this event is not generated.
     *  In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate
     *  this event upon receiving the operation completion via callback.
     */
    readonly NexusOperationStartedEventAttributes: {
      /**
       * @description The operation ID returned by the Nexus handler in the response to the StartOperation request.
       *  This ID is used when canceling the operation.
       *
       *  Deprecated: Renamed to operation_token.
       */
      readonly operationId?: string;
      /**
       * @description The operation token returned by the Nexus handler in the response to the StartOperation request.
       *  This token is used when canceling the operation.
       */
      readonly operationToken?: string;
      /** @description The request ID allocated at schedule time. */
      readonly requestId?: string;
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to. */
      readonly scheduledEventId?: string;
    };
    /** @description Nexus operation timed out. */
    readonly NexusOperationTimedOutEventAttributes: {
      /** @description Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo. */
      readonly failure?: components['schemas']['Failure'];
      /** @description The request ID allocated at schedule time. */
      readonly requestId?: string;
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      readonly scheduledEventId?: string;
    };
    /**
     * @description When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
     *  there is already an existing running workflow, OnConflictOptions defines actions to be taken on
     *  the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
     *  history event in the running workflow with the changes requested in this object.
     */
    readonly OnConflictOptions: {
      /** @description Attaches the completion callbacks to the running workflow. */
      readonly attachCompletionCallbacks?: boolean;
      /** @description Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event. */
      readonly attachLinks?: boolean;
      /** @description Attaches the request ID to the running workflow. */
      readonly attachRequestId?: boolean;
    };
    /** @description The outcome of a Workflow Update: success or failure. */
    readonly Outcome: {
      readonly failure?: components['schemas']['Failure'];
      readonly success?: components['schemas']['Payloads'];
    };
    readonly PatchScheduleRequest: {
      /** @description The identity of the client who initiated this request. */
      readonly identity?: string;
      /** @description The namespace of the schedule to patch. */
      readonly namespace?: string;
      readonly patch?: components['schemas']['SchedulePatch'];
      /** @description A unique identifier for this update request for idempotence. Typically UUIDv4. */
      readonly requestId?: string;
      /** @description The id of the schedule to patch. */
      readonly scheduleId?: string;
    };
    readonly PatchScheduleResponse: Record<string, unknown>;
    readonly PauseActivityRequest: {
      /** @description Execution info of the workflow which scheduled this activity */
      readonly execution?: components['schemas']['WorkflowExecution'];
      /** @description Only the activity with this ID will be paused. */
      readonly id?: string;
      /** @description The identity of the client who initiated this request. */
      readonly identity?: string;
      /** @description Namespace of the workflow which scheduled this activity. */
      readonly namespace?: string;
      /** @description Pause all running activities of this type. */
      readonly type?: string;
    };
    readonly PauseActivityResponse: Record<string, unknown>;
    /**
     * @description Represents some binary (byte array) data (ex: activity input parameters or workflow result) with
     *  metadata which describes this binary data (format, encoding, encryption, etc). Serialization
     *  of the data may be user-defined.
     */
    readonly Payload: unknown;
    /** @description See `Payload` */
    readonly Payloads: {
      readonly payloads?: readonly components['schemas']['Payload'][];
    };
    readonly PendingActivityInfo: {
      readonly activityId?: string;
      readonly activityType?: components['schemas']['ActivityType'];
      /** Format: int32 */
      readonly attempt?: number;
      /**
       * @description The time activity will wait until the next retry.
       *  If activity is currently running it will be next retry interval if activity failed.
       *  If activity is currently waiting it will be current retry interval.
       *  If there will be no retry it will be null.
       */
      readonly currentRetryInterval?: string;
      /** Format: date-time */
      readonly expirationTime?: string;
      readonly heartbeatDetails?: components['schemas']['Payloads'];
      /**
       * Format: date-time
       * @description The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
       */
      readonly lastAttemptCompleteTime?: string;
      /**
       * @description The deployment this activity was dispatched to most recently. Present only if the activity
       *  was dispatched to a versioned worker.
       *  Deprecated. Use `last_worker_deployment_version`.
       */
      readonly lastDeployment?: components['schemas']['Deployment'];
      readonly lastFailure?: components['schemas']['Failure'];
      /** Format: date-time */
      readonly lastHeartbeatTime?: string;
      /**
       * @description This means the activity is independently versioned and not bound to the build ID of its workflow.
       *  The activity will use the build id in this field instead.
       *  If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
       *  rules.
       */
      readonly lastIndependentlyAssignedBuildId?: string;
      /** Format: date-time */
      readonly lastStartedTime?: string;
      /** @description The Worker Deployment Version this activity was dispatched to most recently. */
      readonly lastWorkerDeploymentVersion?: string;
      readonly lastWorkerIdentity?: string;
      /**
       * @description The version stamp of the worker to whom this activity was most recently dispatched
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly lastWorkerVersionStamp?: components['schemas']['WorkerVersionStamp'];
      /** Format: int32 */
      readonly maximumAttempts?: number;
      /**
       * Format: date-time
       * @description Next time when activity will be scheduled.
       *  If activity is currently scheduled or started it will be null.
       */
      readonly nextAttemptScheduleTime?: string;
      /** @description Indicates if activity is paused. */
      readonly paused?: boolean;
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      /** Format: date-time */
      readonly scheduledTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'PENDING_ACTIVITY_STATE_UNSPECIFIED'
        | 'PENDING_ACTIVITY_STATE_SCHEDULED'
        | 'PENDING_ACTIVITY_STATE_STARTED'
        | 'PENDING_ACTIVITY_STATE_CANCEL_REQUESTED'
        | 'PENDING_ACTIVITY_STATE_PAUSED'
        | 'PENDING_ACTIVITY_STATE_PAUSE_REQUESTED';
    };
    readonly PendingChildExecutionInfo: {
      readonly initiatedId?: string;
      /**
       * Format: enum
       * @description Default: PARENT_CLOSE_POLICY_TERMINATE.
       * @enum {string}
       */
      readonly parentClosePolicy?:
        | 'PARENT_CLOSE_POLICY_UNSPECIFIED'
        | 'PARENT_CLOSE_POLICY_TERMINATE'
        | 'PARENT_CLOSE_POLICY_ABANDON'
        | 'PARENT_CLOSE_POLICY_REQUEST_CANCEL';
      readonly runId?: string;
      readonly workflowId?: string;
      readonly workflowTypeName?: string;
    };
    /** @description PendingNexusOperationInfo contains the state of a pending Nexus operation. */
    readonly PendingNexusOperationInfo: {
      /**
       * Format: int32
       * @description The number of attempts made to deliver the start operation request.
       *  This number represents a minimum bound since the attempt is incremented after the request completes.
       */
      readonly attempt?: number;
      /** @description If the state is BLOCKED, blocked reason provides additional information. */
      readonly blockedReason?: string;
      readonly cancellationInfo?: components['schemas']['NexusOperationCancellationInfo'];
      /**
       * @description Endpoint name.
       *  Resolved to a URL via the cluster's endpoint registry.
       */
      readonly endpoint?: string;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      readonly lastAttemptCompleteTime?: string;
      /** @description The last attempt's failure, if any. */
      readonly lastAttemptFailure?: components['schemas']['Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      readonly nextAttemptScheduleTime?: string;
      /** @description Operation name. */
      readonly operation?: string;
      /**
       * @description Operation ID. Only set for asynchronous operations after a successful StartOperation call.
       *
       *  Deprecated: Renamed to operation_token.
       */
      readonly operationId?: string;
      /** @description Operation token. Only set for asynchronous operations after a successful StartOperation call. */
      readonly operationToken?: string;
      /**
       * @description The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
       *  DescribeWorkflowExecution response with workflow history.
       */
      readonly scheduledEventId?: string;
      /**
       * Format: date-time
       * @description The time when the operation was scheduled.
       */
      readonly scheduledTime?: string;
      /**
       * @description Schedule-to-close timeout for this operation.
       *  This is the only timeout settable by a workflow.
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly scheduleToCloseTimeout?: string;
      /** @description Service name. */
      readonly service?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED'
        | 'PENDING_NEXUS_OPERATION_STATE_SCHEDULED'
        | 'PENDING_NEXUS_OPERATION_STATE_BACKING_OFF'
        | 'PENDING_NEXUS_OPERATION_STATE_STARTED'
        | 'PENDING_NEXUS_OPERATION_STATE_BLOCKED';
    };
    readonly PendingWorkflowTaskInfo: {
      /** Format: int32 */
      readonly attempt?: number;
      /**
       * Format: date-time
       * @description original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
       *  Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
       *  In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
       *  some threshold, the workflow task will be forced timeout.
       */
      readonly originalScheduledTime?: string;
      /** Format: date-time */
      readonly scheduledTime?: string;
      /** Format: date-time */
      readonly startedTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly state?:
        | 'PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED'
        | 'PENDING_WORKFLOW_TASK_STATE_SCHEDULED'
        | 'PENDING_WORKFLOW_TASK_STATE_STARTED';
    };
    readonly PollerInfo: {
      /** @description Worker deployment options that SDK sent to server. */
      readonly deploymentOptions?: components['schemas']['WorkerDeploymentOptions'];
      readonly identity?: string;
      /** Format: date-time */
      readonly lastAccessTime?: string;
      /** Format: double */
      readonly ratePerSecond?: number;
      /**
       * @description If a worker has opted into the worker versioning feature while polling, its capabilities will
       *  appear here.
       *  Deprecated. Replaced by deployment_options.
       */
      readonly workerVersionCapabilities?: components['schemas']['WorkerVersionCapabilities'];
    };
    /**
     * @description Attached to task responses to give hints to the SDK about how it may adjust its number of
     *  pollers.
     */
    readonly PollerScalingDecision: {
      /**
       * Format: int32
       * @description How many poll requests to suggest should be added or removed, if any. As of now, server only
       *  scales up or down by 1. However, SDKs should allow for other values (while staying within
       *  defined min/max).
       *
       *  The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
       *  all slots are already occupied.
       */
      readonly pollRequestDeltaSuggestion?: number;
    };
    readonly PollWorkflowTaskQueueResponse: {
      /**
       * Format: int32
       * @description Starting at 1, the number of attempts to complete this task by any worker.
       */
      readonly attempt?: number;
      /**
       * @description A hint that there are more tasks already present in this task queue
       *  partition. Can be used to prioritize draining a sticky queue.
       *
       *  Specifically, the returned number is the number of tasks remaining in
       *  the in-memory buffer for this partition, which is currently capped at
       *  1000. Because sticky queues only have one partition, this number is
       *  more useful when draining them. Normal queues, typically having more than one
       *  partition, will return a number representing only some portion of the
       *  overall backlog. Subsequent RPCs may not hit the same partition as
       *  this call.
       */
      readonly backlogCountHint?: string;
      /**
       * @description The history for this workflow, which will either be complete or partial. Partial histories
       *  are sent to workers who have signaled that they are using a sticky queue when completing
       *  a workflow task.
       */
      readonly history?: components['schemas']['History'];
      /** @description Protocol messages piggybacking on a WFT as a transport */
      readonly messages?: readonly components['schemas']['Message'][];
      /**
       * Format: bytes
       * @description Will be set if there are more history events than were included in this response. Such events
       *  should be fetched via `GetWorkflowExecutionHistory`.
       */
      readonly nextPageToken?: string;
      /** @description Server-advised information the SDK may use to adjust its poller count. */
      readonly pollerScalingDecision?: components['schemas']['PollerScalingDecision'];
      /**
       * @description The last workflow task started event which was processed by some worker for this execution.
       *  Will be zero if no task has ever started.
       */
      readonly previousStartedEventId?: string;
      /**
       * @description Queries that should be executed after applying the history in this task. Responses should be
       *  attached to `RespondWorkflowTaskCompletedRequest::query_results`
       */
      readonly queries?: {
        [key: string]: components['schemas']['WorkflowQuery'];
      };
      /**
       * @description Legacy queries appear in this field. The query must be responded to via
       *  `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
       *  closed workflows) then the `history` field will be populated with the entire history. It
       *  may also be populated if this task originates on a non-sticky queue.
       */
      readonly query?: components['schemas']['WorkflowQuery'];
      /**
       * Format: date-time
       * @description When this task was scheduled by the server
       */
      readonly scheduledTime?: string;
      /**
       * @description The id of the most recent workflow task started event, which will have been generated as a
       *  result of this poll request being served. Will be zero if the task
       *  does not contain any events which would advance history (no new WFT started).
       *  Currently this can happen for queries.
       */
      readonly startedEventId?: string;
      /**
       * Format: date-time
       * @description When the current workflow task started event was generated, meaning the current attempt.
       */
      readonly startedTime?: string;
      /**
       * Format: bytes
       * @description A unique identifier for this task
       */
      readonly taskToken?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description The task queue this task originated from, which will always be the original non-sticky name
       *  for the queue, even if this response came from polling a sticky queue.
       */
      readonly workflowExecutionTaskQueue?: components['schemas']['TaskQueue'];
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    /**
     * @description Priority contains metadata that controls relative ordering of task processing
     *  when tasks are backlogged in a queue. Initially, Priority will be used in
     *  activity and workflow task queues, which are typically where backlogs exist.
     *  Other queues in the server (such as transfer and timer queues) and rate
     *  limiting decisions do not use Priority, but may in the future.
     *
     *  Priority is attached to workflows and activities. Activities and child
     *  workflows inherit Priority from the workflow that created them, but may
     *  override fields when they are started or modified. For each field of a
     *  Priority on an activity/workflow, not present or equal to zero/empty string
     *  means to inherit the value from the calling workflow, or if there is no
     *  calling workflow, then use the default (documented below).
     *
     *  Despite being named "Priority", this message will also contains fields that
     *  control "fairness" mechanisms.
     *
     *  The overall semantics of Priority are:
     *  1. First, consider "priority_key": lower number goes first.
     *  (more will be added here later)
     */
    readonly Priority: {
      /**
       * Format: int32
       * @description Priority key is a positive integer from 1 to n, where smaller integers
       *  correspond to higher priorities (tasks run sooner). In general, tasks in
       *  a queue should be processed in close to priority order, although small
       *  deviations are possible.
       *
       *  The maximum priority value (minimum priority) is determined by server
       *  configuration, and defaults to 5.
       *
       *  The default priority is (min+max)/2. With the default max of 5 and min of
       *  1, that comes out to 3.
       */
      readonly priorityKey?: number;
    };
    readonly QueryRejected: {
      /**
       * Format: enum
       * @enum {string}
       */
      readonly status?:
        | 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED'
        | 'WORKFLOW_EXECUTION_STATUS_RUNNING'
        | 'WORKFLOW_EXECUTION_STATUS_COMPLETED'
        | 'WORKFLOW_EXECUTION_STATUS_FAILED'
        | 'WORKFLOW_EXECUTION_STATUS_CANCELED'
        | 'WORKFLOW_EXECUTION_STATUS_TERMINATED'
        | 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW'
        | 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT';
    };
    readonly QueryWorkflowRequest: {
      readonly execution?: components['schemas']['WorkflowExecution'];
      readonly namespace?: string;
      readonly query?: components['schemas']['WorkflowQuery'];
      /**
       * Format: enum
       * @description QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
       *  Default: QUERY_REJECT_CONDITION_NONE.
       * @enum {string}
       */
      readonly queryRejectCondition?:
        | 'QUERY_REJECT_CONDITION_UNSPECIFIED'
        | 'QUERY_REJECT_CONDITION_NONE'
        | 'QUERY_REJECT_CONDITION_NOT_OPEN'
        | 'QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY';
    };
    readonly QueryWorkflowResponse: {
      readonly queryRejected?: components['schemas']['QueryRejected'];
      readonly queryResult?: components['schemas']['Payloads'];
    };
    readonly RampByPercentage: {
      /**
       * Format: float
       * @description Acceptable range is [0,100).
       */
      readonly rampPercentage?: number;
    };
    /**
     * @description Range represents a set of integer values, used to match fields of a calendar
     *  time in StructuredCalendarSpec. If end < start, then end is interpreted as
     *  equal to start. This means you can use a Range with start set to a value, and
     *  end and step unset (defaulting to 0) to represent a single value.
     */
    readonly Range: {
      /**
       * Format: int32
       * @description End of range (inclusive).
       */
      readonly end?: number;
      /**
       * Format: int32
       * @description Start of range (inclusive).
       */
      readonly start?: number;
      /**
       * Format: int32
       * @description Step (optional, default 1).
       */
      readonly step?: number;
    };
    readonly RecordActivityTaskHeartbeatByIdRequest: {
      /** @description Id of the activity we're heartbeating */
      readonly activityId?: string;
      /** @description Arbitrary data, of which the most recent call is kept, to store for this activity */
      readonly details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Namespace of the workflow which scheduled this activity */
      readonly namespace?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      readonly runId?: string;
      /** @description Id of the workflow which scheduled this activity */
      readonly workflowId?: string;
    };
    readonly RecordActivityTaskHeartbeatByIdResponse: {
      /** @description Will be set to true if the activity is paused. */
      readonly activityPaused?: boolean;
      /**
       * @description Will be set to true if the activity has been asked to cancel itself. The SDK should then
       *  notify the activity of cancellation if it is still running.
       */
      readonly cancelRequested?: boolean;
    };
    readonly RecordActivityTaskHeartbeatRequest: {
      /** @description Arbitrary data, of which the most recent call is kept, to store for this activity */
      readonly details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      readonly namespace?: string;
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      readonly taskToken?: string;
    };
    readonly RecordActivityTaskHeartbeatResponse: {
      /** @description Will be set to true if the activity is paused. */
      readonly activityPaused?: boolean;
      /**
       * @description Will be set to true if the activity has been asked to cancel itself. The SDK should then
       *  notify the activity of cancellation if it is still running.
       */
      readonly cancelRequested?: boolean;
    };
    readonly RegisterNamespaceRequest: {
      readonly activeClusterName?: string;
      readonly clusters?: readonly components['schemas']['ClusterReplicationConfig'][];
      /** @description A key-value map for any customized purpose. */
      readonly data?: {
        [key: string]: string;
      };
      readonly description?: string;
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      readonly historyArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      readonly historyArchivalUri?: string;
      readonly isGlobalNamespace?: boolean;
      readonly namespace?: string;
      readonly ownerEmail?: string;
      readonly securityToken?: string;
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      readonly visibilityArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      readonly visibilityArchivalUri?: string;
      readonly workflowExecutionRetentionPeriod?: string;
    };
    readonly RegisterNamespaceResponse: Record<string, unknown>;
    /** @description ReleaseInfo contains information about specific version of temporal. */
    readonly ReleaseInfo: {
      readonly notes?: string;
      /** Format: date-time */
      readonly releaseTime?: string;
      readonly version?: string;
    };
    /** @description The client request that triggers a Workflow Update. */
    readonly Request: {
      readonly input?: components['schemas']['Input'];
      readonly meta?: components['schemas']['Meta'];
    };
    readonly RequestCancelExternalWorkflowExecutionFailedEventAttributes: {
      /**
       * Format: enum
       * @enum {string}
       */
      readonly cause?:
        | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
        | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND'
        | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND';
      /** @description Deprecated */
      readonly control?: string;
      /**
       * @description id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure
       *  corresponds to
       */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the workflow which failed to cancel.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly RequestCancelExternalWorkflowExecutionInitiatedEventAttributes: {
      /**
       * @description Workers are expected to set this to true if the workflow they are requesting to cancel is
       *  a child of the workflow which issued the request
       */
      readonly childWorkflowOnly?: boolean;
      /** @description Deprecated */
      readonly control?: string;
      /**
       * @description The namespace the workflow to be cancelled lives in.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /** @description Reason for requesting the cancellation */
      readonly reason?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly RequestCancelWorkflowExecutionRequest: {
      /**
       * @description If set, this call will error if the most recent (if no run id is set on
       *  `workflow_execution`), or specified (if it is) workflow execution is not part of the same
       *  execution chain as this id.
       */
      readonly firstExecutionRunId?: string;
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Links to be associated with the WorkflowExecutionCanceled event. */
      readonly links?: readonly components['schemas']['Link'][];
      readonly namespace?: string;
      /** @description Reason for requesting the cancellation */
      readonly reason?: string;
      /** @description Used to de-dupe cancellation requests */
      readonly requestId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    readonly RequestCancelWorkflowExecutionResponse: Record<string, unknown>;
    readonly ResetActivityRequest: {
      /** @description Execution info of the workflow which scheduled this activity */
      readonly execution?: components['schemas']['WorkflowExecution'];
      /** @description Only activity with this ID will be reset. */
      readonly id?: string;
      /** @description The identity of the client who initiated this request. */
      readonly identity?: string;
      /**
       * @description If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
       *  (unless it is paused and keep_paused is set)
       */
      readonly jitter?: string;
      /** @description if activity is paused, it will remain paused after reset */
      readonly keepPaused?: boolean;
      /** @description Namespace of the workflow which scheduled this activity. */
      readonly namespace?: string;
      /**
       * @description Indicates that activity should reset heartbeat details.
       *  This flag will be applied only to the new instance of the activity.
       */
      readonly resetHeartbeat?: boolean;
      /** @description Reset all running activities with of this type. */
      readonly type?: string;
    };
    readonly ResetActivityResponse: Record<string, unknown>;
    /**
     * @description Describes where and how to reset a workflow, used for batch reset currently
     *  and may be used for single-workflow reset later.
     */
    readonly ResetOptions: {
      /**
       * @description Resets to the first workflow task processed by this build id.
       *  If the workflow was not processed by the build id, or the workflow task can't be
       *  determined, no reset will be performed.
       *  Note that by default, this reset is allowed to be to a prior run in a chain of
       *  continue-as-new.
       */
      readonly buildId?: string;
      /**
       * @description If true, limit the reset to only within the current run. (Applies to build_id targets and
       *  possibly others in the future.)
       */
      readonly currentRunOnly?: boolean;
      /** @description Event types not to be reapplied */
      readonly resetReapplyExcludeTypes?: readonly (
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UPDATE'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_NEXUS'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST'
      )[];
      /**
       * Format: enum
       * @description Event types to be reapplied (deprecated)
       *  Default: RESET_REAPPLY_TYPE_SIGNAL
       * @enum {string}
       */
      readonly resetReapplyType?:
        | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_TYPE_SIGNAL'
        | 'RESET_REAPPLY_TYPE_NONE'
        | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
      /**
       * @description The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
       *  `WORKFLOW_TASK_STARTED` event to reset to.
       *  Note that this option doesn't make sense when used as part of a batch request.
       */
      readonly workflowTaskId?: string;
    };
    /**
     * @description ResetPointInfo records the workflow event id that is the first one processed by a given
     *  build id or binary checksum. A new reset point will be created if either build id or binary
     *  checksum changes (although in general only one or the other will be used at a time).
     */
    readonly ResetPointInfo: {
      /** @description A worker binary version identifier (deprecated). */
      readonly binaryChecksum?: string;
      /** @description Worker build id. */
      readonly buildId?: string;
      /** Format: date-time */
      readonly createTime?: string;
      /**
       * Format: date-time
       * @description (-- api-linter: core::0214::resource-expiry=disabled
       *      aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
       *  The time that the run is deleted due to retention.
       */
      readonly expireTime?: string;
      /** @description Event ID of the first WorkflowTaskCompleted event processed by this worker build. */
      readonly firstWorkflowTaskCompletedId?: string;
      /** @description false if the reset point has pending childWFs/reqCancels/signalExternals. */
      readonly resettable?: boolean;
      /** @description The first run ID in the execution chain that was touched by this worker build. */
      readonly runId?: string;
    };
    readonly ResetPoints: {
      readonly points?: readonly components['schemas']['ResetPointInfo'][];
    };
    readonly ResetWorkflowExecutionRequest: {
      readonly namespace?: string;
      readonly reason?: string;
      /** @description Used to de-dupe reset requests */
      readonly requestId?: string;
      /** @description Event types not to be reapplied */
      readonly resetReapplyExcludeTypes?: readonly (
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UPDATE'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_NEXUS'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST'
      )[];
      /**
       * Format: enum
       * @description Event types to be reapplied (deprecated)
       *  Default: RESET_REAPPLY_TYPE_SIGNAL
       * @enum {string}
       */
      readonly resetReapplyType?:
        | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_TYPE_SIGNAL'
        | 'RESET_REAPPLY_TYPE_NONE'
        | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
      /**
       * @description The workflow to reset. If this contains a run ID then the workflow will be reset back to the
       *  provided event ID in that run. Otherwise it will be reset to the provided event ID in the
       *  current run. In all cases the current run will be terminated and a new run started.
       */
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
       *  `WORKFLOW_TASK_STARTED` event to reset to.
       */
      readonly workflowTaskFinishEventId?: string;
    };
    readonly ResetWorkflowExecutionResponse: {
      readonly runId?: string;
    };
    readonly ResetWorkflowFailureInfo: {
      readonly lastHeartbeatDetails?: components['schemas']['Payloads'];
    };
    readonly RespondActivityTaskCanceledByIdRequest: {
      /** @description Id of the activity to confirm is cancelled */
      readonly activityId?: string;
      /** @description Serialized additional information to attach to the cancellation */
      readonly details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Namespace of the workflow which scheduled this activity */
      readonly namespace?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      readonly runId?: string;
      /** @description Id of the workflow which scheduled this activity */
      readonly workflowId?: string;
    };
    readonly RespondActivityTaskCanceledByIdResponse: Record<string, unknown>;
    readonly RespondActivityTaskCanceledRequest: {
      /**
       * @description Deployment info of the worker that completed this task. Must be present if user has set
       *  `WorkerDeploymentOptions` regardless of versioning being enabled or not.
       *  Deprecated. Replaced with `deployment_options`.
       */
      readonly deployment?: components['schemas']['Deployment'];
      /** @description Worker deployment options that user has set in the worker. */
      readonly deploymentOptions?: components['schemas']['WorkerDeploymentOptions'];
      /** @description Serialized additional information to attach to the cancellation */
      readonly details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      readonly namespace?: string;
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      readonly taskToken?: string;
      /**
       * @description Version info of the worker who processed this task. This message's `build_id` field should
       *  always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
       *  field to true. See message docstrings for more.
       *  Deprecated. Use `deployment` instead.
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly RespondActivityTaskCanceledResponse: Record<string, unknown>;
    readonly RespondActivityTaskCompletedByIdRequest: {
      /** @description Id of the activity to complete */
      readonly activityId?: string;
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Namespace of the workflow which scheduled this activity */
      readonly namespace?: string;
      /** @description The serialized result of activity execution */
      readonly result?: components['schemas']['Payloads'];
      /** @description Run Id of the workflow which scheduled this activity */
      readonly runId?: string;
      /** @description Id of the workflow which scheduled this activity */
      readonly workflowId?: string;
    };
    readonly RespondActivityTaskCompletedByIdResponse: Record<string, unknown>;
    readonly RespondActivityTaskCompletedRequest: {
      /**
       * @description Deployment info of the worker that completed this task. Must be present if user has set
       *  `WorkerDeploymentOptions` regardless of versioning being enabled or not.
       *  Deprecated. Replaced with `deployment_options`.
       */
      readonly deployment?: components['schemas']['Deployment'];
      /** @description Worker deployment options that user has set in the worker. */
      readonly deploymentOptions?: components['schemas']['WorkerDeploymentOptions'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      readonly namespace?: string;
      /** @description The result of successfully executing the activity */
      readonly result?: components['schemas']['Payloads'];
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      readonly taskToken?: string;
      /**
       * @description Version info of the worker who processed this task. This message's `build_id` field should
       *  always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
       *  field to true. See message docstrings for more.
       *  Deprecated. Use `deployment` instead.
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly RespondActivityTaskCompletedResponse: Record<string, unknown>;
    readonly RespondActivityTaskFailedByIdRequest: {
      /** @description Id of the activity to fail */
      readonly activityId?: string;
      /** @description Detailed failure information */
      readonly failure?: components['schemas']['Failure'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Additional details to be stored as last activity heartbeat */
      readonly lastHeartbeatDetails?: components['schemas']['Payloads'];
      /** @description Namespace of the workflow which scheduled this activity */
      readonly namespace?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      readonly runId?: string;
      /** @description Id of the workflow which scheduled this activity */
      readonly workflowId?: string;
    };
    readonly RespondActivityTaskFailedByIdResponse: {
      /**
       * @description Server validation failures could include
       *  last_heartbeat_details payload is too large, request failure is too large
       */
      readonly failures?: readonly components['schemas']['Failure'][];
    };
    readonly RespondActivityTaskFailedRequest: {
      /**
       * @description Deployment info of the worker that completed this task. Must be present if user has set
       *  `WorkerDeploymentOptions` regardless of versioning being enabled or not.
       *  Deprecated. Replaced with `deployment_options`.
       */
      readonly deployment?: components['schemas']['Deployment'];
      /** @description Worker deployment options that user has set in the worker. */
      readonly deploymentOptions?: components['schemas']['WorkerDeploymentOptions'];
      /** @description Detailed failure information */
      readonly failure?: components['schemas']['Failure'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Additional details to be stored as last activity heartbeat */
      readonly lastHeartbeatDetails?: components['schemas']['Payloads'];
      readonly namespace?: string;
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      readonly taskToken?: string;
      /**
       * @description Version info of the worker who processed this task. This message's `build_id` field should
       *  always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
       *  field to true. See message docstrings for more.
       *  Deprecated. Use `deployment` instead.
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly RespondActivityTaskFailedResponse: {
      /**
       * @description Server validation failures could include
       *  last_heartbeat_details payload is too large, request failure is too large
       */
      readonly failures?: readonly components['schemas']['Failure'][];
    };
    /** @description How retries ought to be handled, usable by both workflows and activities */
    readonly RetryPolicy: {
      /**
       * Format: double
       * @description Coefficient used to calculate the next retry interval.
       *  The next retry interval is previous interval multiplied by the coefficient.
       *  Must be 1 or larger.
       */
      readonly backoffCoefficient?: number;
      /** @description Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries. */
      readonly initialInterval?: string;
      /**
       * Format: int32
       * @description Maximum number of attempts. When exceeded the retries stop even if not expired yet.
       *  1 disables retries. 0 means unlimited (up to the timeouts)
       */
      readonly maximumAttempts?: number;
      /**
       * @description Maximum interval between retries. Exponential backoff leads to interval increase.
       *  This value is the cap of the increase. Default is 100x of the initial interval.
       */
      readonly maximumInterval?: string;
      /**
       * @description Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
       *  this is not a substring match, the error *type* (not message) must match exactly.
       */
      readonly nonRetryableErrorTypes?: readonly string[];
    };
    readonly RoutingConfig: {
      /**
       * @description Always present. Specifies which Deployment Version should should receive new workflow
       *  executions and tasks of existing unversioned or AutoUpgrade workflows.
       *  Can be one of the following:
       *  - A Deployment Version identifier in the form "<deployment_name>.<build_id>".
       *  - Or, the "__unversioned__" special value, to represent all the unversioned workers (those
       *    with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
       *  Note: Current Version is overridden by the Ramping Version for a portion of traffic when a ramp
       *  is set (see `ramping_version`.)
       */
      readonly currentVersion?: string;
      /**
       * Format: date-time
       * @description Last time current version was changed.
       */
      readonly currentVersionChangedTime?: string;
      /**
       * @description When present, it means the traffic is being shifted from the Current Version to the Ramping
       *  Version.
       *  Must always be different from Current Version. Can be one of the following:
       *  - A Deployment Version identifier in the form "<deployment_name>.<build_id>".
       *  - Or, the "__unversioned__" special value, to represent all the unversioned workers (those
       *    with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
       *  Note that it is possible to ramp from one Version to another Version, or from unversioned
       *  workers to a particular Version, or from a particular Version to unversioned workers.
       */
      readonly rampingVersion?: string;
      /**
       * Format: date-time
       * @description Last time ramping version was changed. Not updated if only the ramp percentage changes.
       */
      readonly rampingVersionChangedTime?: string;
      /**
       * Format: float
       * @description Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
       *  Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
       *  not yet "promoted" to be the Current Version, likely due to pending validations.
       */
      readonly rampingVersionPercentage?: number;
      /**
       * Format: date-time
       * @description Last time ramping version percentage was changed.
       *  If ramping version is changed, this is also updated, even if the percentage stays the same.
       */
      readonly rampingVersionPercentageChangedTime?: string;
    };
    readonly Schedule: {
      readonly action?: components['schemas']['ScheduleAction'];
      readonly policies?: components['schemas']['SchedulePolicies'];
      readonly spec?: components['schemas']['ScheduleSpec'];
      readonly state?: components['schemas']['ScheduleState'];
    };
    readonly ScheduleAction: {
      /**
       * @description All fields of NewWorkflowExecutionInfo are valid except for:
       *  - workflow_id_reuse_policy
       *  - cron_schedule
       *  The workflow id of the started workflow may not match this exactly,
       *  it may have a timestamp appended for uniqueness.
       */
      readonly startWorkflow?: components['schemas']['NewWorkflowExecutionInfo'];
    };
    readonly ScheduleActionResult: {
      /**
       * Format: date-time
       * @description Time that the action was taken (real time).
       */
      readonly actualTime?: string;
      /**
       * Format: date-time
       * @description Time that the action was taken (according to the schedule, including jitter).
       */
      readonly scheduleTime?: string;
      /** @description If action was start_workflow: */
      readonly startWorkflowResult?: components['schemas']['WorkflowExecution'];
      /**
       * Format: enum
       * @description If the action was start_workflow, this field will reflect an
       *  eventually-consistent view of the started workflow's status.
       * @enum {string}
       */
      readonly startWorkflowStatus?:
        | 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED'
        | 'WORKFLOW_EXECUTION_STATUS_RUNNING'
        | 'WORKFLOW_EXECUTION_STATUS_COMPLETED'
        | 'WORKFLOW_EXECUTION_STATUS_FAILED'
        | 'WORKFLOW_EXECUTION_STATUS_CANCELED'
        | 'WORKFLOW_EXECUTION_STATUS_TERMINATED'
        | 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW'
        | 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT';
    };
    readonly ScheduleInfo: {
      /** @description Number of actions taken so far. */
      readonly actionCount?: string;
      /** @description Number of dropped actions due to buffer limit. */
      readonly bufferDropped?: string;
      /**
       * @description Number of actions in the buffer. The buffer holds the actions that cannot
       *  be immediately triggered (due to the overlap policy). These actions can be a result of
       *  the normal schedule or a backfill.
       */
      readonly bufferSize?: string;
      /**
       * Format: date-time
       * @description Timestamps of schedule creation and last update.
       */
      readonly createTime?: string;
      /** @description Next ten scheduled action times. */
      readonly futureActionTimes?: readonly string[];
      readonly invalidScheduleError?: string;
      /** @description Number of times a scheduled action was skipped due to missing the catchup window. */
      readonly missedCatchupWindow?: string;
      /** @description Number of skipped actions due to overlap. */
      readonly overlapSkipped?: string;
      /** @description Most recent ten actual action times (including manual triggers). */
      readonly recentActions?: readonly components['schemas']['ScheduleActionResult'][];
      /**
       * @description Currently-running workflows started by this schedule. (There might be
       *  more than one if the overlap policy allows overlaps.)
       *  Note that the run_ids in here are the original execution run ids as
       *  started by the schedule. If the workflows retried, did continue-as-new,
       *  or were reset, they might still be running but with a different run_id.
       */
      readonly runningWorkflows?: readonly components['schemas']['WorkflowExecution'][];
      /** Format: date-time */
      readonly updateTime?: string;
    };
    /** @description ScheduleListEntry is returned by ListSchedules. */
    readonly ScheduleListEntry: {
      readonly info?: components['schemas']['ScheduleListInfo'];
      readonly memo?: components['schemas']['Memo'];
      readonly scheduleId?: string;
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
    };
    /**
     * @description ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
     *  that's returned in ListSchedules.
     */
    readonly ScheduleListInfo: {
      readonly futureActionTimes?: readonly string[];
      /** @description From state: */
      readonly notes?: string;
      readonly paused?: boolean;
      /** @description From info (maybe fewer entries): */
      readonly recentActions?: readonly components['schemas']['ScheduleActionResult'][];
      /**
       * @description From spec:
       *  Some fields are dropped from this copy of spec: timezone_data
       */
      readonly spec?: components['schemas']['ScheduleSpec'];
      /**
       * @description From action:
       *  Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
       *  well with JSON. If action is start_workflow, this is set:
       */
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly SchedulePatch: {
      /**
       * @description If set, runs though the specified time period(s) and takes actions as if that time
       *  passed by right now, all at once. The overlap policy can be overridden for the
       *  scope of the backfill.
       */
      readonly backfillRequest?: readonly components['schemas']['BackfillRequest'][];
      /**
       * @description If set, change the state to paused or unpaused (respectively) and set the
       *  notes field to the value of the string.
       */
      readonly pause?: string;
      /** @description If set, trigger one action immediately. */
      readonly triggerImmediately?: components['schemas']['TriggerImmediatelyRequest'];
      readonly unpause?: string;
    };
    readonly SchedulePolicies: {
      /**
       * @description Policy for catchups:
       *  If the Temporal server misses an action due to one or more components
       *  being down, and comes back up, the action will be run if the scheduled
       *  time is within this window from the current time.
       *  This value defaults to one year, and can't be less than 10 seconds.
       */
      readonly catchupWindow?: string;
      /**
       * @description If true, and the action would start a workflow, a timestamp will not be
       *  appended to the scheduled workflow id.
       */
      readonly keepOriginalWorkflowId?: boolean;
      /**
       * Format: enum
       * @description Policy for overlaps.
       *  Note that this can be changed after a schedule has taken some actions,
       *  and some changes might produce unintuitive results. In general, the later
       *  policy overrides the earlier policy.
       * @enum {string}
       */
      readonly overlapPolicy?:
        | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
        | 'SCHEDULE_OVERLAP_POLICY_SKIP'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
        | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
      /**
       * @description If true, and a workflow run fails or times out, turn on "paused".
       *  This applies after retry policies: the full chain of retries must fail to
       *  trigger a pause here.
       */
      readonly pauseOnFailure?: boolean;
    };
    /**
     * @description ScheduleSpec is a complete description of a set of absolute timestamps
     *  (possibly infinite) that an action should occur at. The meaning of a
     *  ScheduleSpec depends only on its contents and never changes, except that the
     *  definition of a time zone can change over time (most commonly, when daylight
     *  saving time policy changes for an area). To create a totally self-contained
     *  ScheduleSpec, use UTC or include timezone_data.
     *
     *  For input, you can provide zero or more of: structured_calendar, calendar,
     *  cron_string, interval, and exclude_structured_calendar, and all of them will
     *  be used (the schedule will take action at the union of all of their times,
     *  minus the ones that match exclude_structured_calendar).
     *
     *  On input, calendar and cron_string fields will be compiled into
     *  structured_calendar (and maybe interval and timezone_name), so if you
     *  Describe a schedule, you'll see only structured_calendar, interval, etc.
     *
     *  If a spec has no matching times after the current time, then the schedule
     *  will be subject to automatic deletion (after several days).
     */
    readonly ScheduleSpec: {
      /** @description Calendar-based specifications of times. */
      readonly calendar?: readonly components['schemas']['CalendarSpec'][];
      /**
       * @description cron_string holds a traditional cron specification as a string. It
       *  accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
       *  same way as CalendarSpec.
       *  5 fields:         minute, hour, day_of_month, month, day_of_week
       *  6 fields:         minute, hour, day_of_month, month, day_of_week, year
       *  7 fields: second, minute, hour, day_of_month, month, day_of_week, year
       *  If year is not given, it defaults to *. If second is not given, it
       *  defaults to 0.
       *  Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
       *  accepted instead of the 5-7 time fields.
       *  Optionally, the string can be preceded by CRON_TZ=<timezone name> or
       *  TZ=<timezone name>, which will get copied to timezone_name. (There must
       *  not also be a timezone_name present.)
       *  Optionally "#" followed by a comment can appear at the end of the string.
       *  Note that the special case that some cron implementations have for
       *  treating day_of_month and day_of_week as "or" instead of "and" when both
       *  are set is not implemented.
       *  @every <interval>[/<phase>] is accepted and gets compiled into an
       *  IntervalSpec instead. <interval> and <phase> should be a decimal integer
       *  with a unit suffix s, m, h, or d.
       */
      readonly cronString?: readonly string[];
      /**
       * Format: date-time
       * @description If end_time is set, any timestamps after end_time will be skipped.
       */
      readonly endTime?: string;
      /** @description Any timestamps matching any of exclude_* will be skipped. */
      readonly excludeCalendar?: readonly components['schemas']['CalendarSpec'][];
      readonly excludeStructuredCalendar?: readonly components['schemas']['StructuredCalendarSpec'][];
      /** @description Interval-based specifications of times. */
      readonly interval?: readonly components['schemas']['IntervalSpec'][];
      /**
       * @description All timestamps will be incremented by a random value from 0 to this
       *  amount of jitter. Default: 0
       */
      readonly jitter?: string;
      /**
       * Format: date-time
       * @description If start_time is set, any timestamps before start_time will be skipped.
       *  (Together, start_time and end_time make an inclusive interval.)
       */
      readonly startTime?: string;
      /** @description Calendar-based specifications of times. */
      readonly structuredCalendar?: readonly components['schemas']['StructuredCalendarSpec'][];
      /** Format: bytes */
      readonly timezoneData?: string;
      /**
       * @description Time zone to interpret all calendar-based specs in.
       *
       *  If unset, defaults to UTC. We recommend using UTC for your application if
       *  at all possible, to avoid various surprising properties of time zones.
       *
       *  Time zones may be provided by name, corresponding to names in the IANA
       *  time zone database (see https://www.iana.org/time-zones). The definition
       *  will be loaded by the Temporal server from the environment it runs in.
       *
       *  If your application requires more control over the time zone definition
       *  used, it may pass in a complete definition in the form of a TZif file
       *  from the time zone database. If present, this will be used instead of
       *  loading anything from the environment. You are then responsible for
       *  updating timezone_data when the definition changes.
       *
       *  Calendar spec matching is based on literal matching of the clock time
       *  with no special handling of DST: if you write a calendar spec that fires
       *  at 2:30am and specify a time zone that follows DST, that action will not
       *  be triggered on the day that has no 2:30am. Similarly, an action that
       *  fires at 1:30am will be triggered twice on the day that has two 1:30s.
       *
       *  Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
       */
      readonly timezoneName?: string;
    };
    readonly ScheduleState: {
      /**
       * @description If limited_actions is true, decrement remaining_actions after each
       *  action, and do not take any more scheduled actions if remaining_actions
       *  is zero. Actions may still be taken by explicit request (i.e. trigger
       *  immediately or backfill). Skipped actions (due to overlap policy) do not
       *  count against remaining actions.
       *  If a schedule has no more remaining actions, then the schedule will be
       *  subject to automatic deletion (after several days).
       */
      readonly limitedActions?: boolean;
      /**
       * @description Informative human-readable message with contextual notes, e.g. the reason
       *  a schedule is paused. The system may overwrite this message on certain
       *  conditions, e.g. when pause-on-failure happens.
       */
      readonly notes?: string;
      /** @description If true, do not take any actions based on the schedule spec. */
      readonly paused?: boolean;
      readonly remainingActions?: string;
    };
    /**
     * @description A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
     *  The payload is not serialized in a user-defined way.
     */
    readonly SearchAttributes: {
      readonly indexedFields?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    readonly ServerFailureInfo: {
      readonly nonRetryable?: boolean;
    };
    /** @description [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    readonly SetCurrentDeploymentRequest: {
      readonly deployment?: components['schemas']['Deployment'];
      /** @description Optional. The identity of the client who initiated this request. */
      readonly identity?: string;
      readonly namespace?: string;
      /**
       * @description Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed
       *  when describing a deployment. It is a good place for information such as operator name,
       *  links to internal deployment pipelines, etc.
       */
      readonly updateMetadata?: components['schemas']['UpdateDeploymentMetadata'];
    };
    /** @description [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    readonly SetCurrentDeploymentResponse: {
      readonly currentDeploymentInfo?: components['schemas']['DeploymentInfo'];
      /** @description Info of the deployment that was current before executing this operation. */
      readonly previousDeploymentInfo?: components['schemas']['DeploymentInfo'];
    };
    /** @description Set/unset the Current Version of a Worker Deployment. */
    readonly SetWorkerDeploymentCurrentVersionRequest: {
      /**
       * Format: bytes
       * @description Optional. This can be the value of conflict_token from a Describe, or another Worker
       *  Deployment API. Passing a non-nil conflict token will cause this request to fail if the
       *  Deployment's configuration has been modified between the API call that generated the
       *  token and this one.
       */
      readonly conflictToken?: string;
      readonly deploymentName?: string;
      /** @description Optional. The identity of the client who initiated this request. */
      readonly identity?: string;
      /**
       * @description Optional. By default this request would be rejected if not all the expected Task Queues are
       *  being polled by the new Version, to protect against accidental removal of Task Queues, or
       *  worker health issues. Pass `true` here to bypass this protection.
       *  The set of expected Task Queues is the set of all the Task Queues that were ever poller by
       *  the existing Current Version of the Deployment, with the following exclusions:
       *    - Task Queues that are not used anymore (inferred by having empty backlog and a task
       *      add_rate of 0.)
       *    - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
       *      having a different Current Version than the Current Version of this deployment.)
       *  WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
       *  needed. If the request is unexpectedly rejected due to missing pollers, then that means the
       *  pollers have not reached to the server yet. Only set this if you expect those pollers to
       *  never arrive.
       */
      readonly ignoreMissingTaskQueues?: boolean;
      readonly namespace?: string;
      /**
       * @description Required. Can be one of the following:
       *  - A Deployment Version identifier in the form "<deployment_name>.<build_id>".
       *  - Or, the "__unversioned__" special value, to represent all the unversioned workers (those
       *    with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
       */
      readonly version?: string;
    };
    readonly SetWorkerDeploymentCurrentVersionResponse: {
      /**
       * Format: bytes
       * @description This value is returned so that it can be optionally passed to APIs
       *  that write to the Worker Deployment state to ensure that the state
       *  did not change between this API call and a future write.
       */
      readonly conflictToken?: string;
      /**
       * @description The version that was current before executing this operation, in the form
       *  "<deployment_name>.<build_id>". Can also be the `__unversioned__` special value.
       */
      readonly previousVersion?: string;
    };
    /** @description Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. */
    readonly SetWorkerDeploymentRampingVersionRequest: {
      /**
       * Format: bytes
       * @description Optional. This can be the value of conflict_token from a Describe, or another Worker
       *  Deployment API. Passing a non-nil conflict token will cause this request to fail if the
       *  Deployment's configuration has been modified between the API call that generated the
       *  token and this one.
       */
      readonly conflictToken?: string;
      readonly deploymentName?: string;
      /** @description Optional. The identity of the client who initiated this request. */
      readonly identity?: string;
      /**
       * @description Optional. By default this request would be rejected if not all the expected Task Queues are
       *  being polled by the new Version, to protect against accidental removal of Task Queues, or
       *  worker health issues. Pass `true` here to bypass this protection.
       *  The set of expected Task Queues equals to all the Task Queues ever polled from the existing
       *  Current Version of the Deployment, with the following exclusions:
       *    - Task Queues that are not used anymore (inferred by having empty backlog and a task
       *      add_rate of 0.)
       *    - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
       *      having a different Current Version than the Current Version of this deployment.)
       *  WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
       *  needed. If the request is unexpectedly rejected due to missing pollers, then that means the
       *  pollers have not reached to the server yet. Only set this if you expect those pollers to
       *  never arrive.
       *  Note: this check only happens when the ramping version is about to change, not every time
       *  that the percentage changes. Also note that the check is against the deployment's Current
       *  Version, not the previous Ramping Version.
       */
      readonly ignoreMissingTaskQueues?: boolean;
      readonly namespace?: string;
      /**
       * Format: float
       * @description Ramp percentage to set. Valid range: [0,100].
       */
      readonly percentage?: number;
      /**
       * @description Can be one of the following:
       *  - Absent/empty value to unset the Ramping Version. Must be paired with `percentage=0`.
       *  - A Deployment Version identifier in the form "<deployment_name>.<build_id>".
       *  - Or, the "__unversioned__" special value, to represent all the unversioned workers (those
       *    with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
       */
      readonly version?: string;
    };
    readonly SetWorkerDeploymentRampingVersionResponse: {
      /**
       * Format: bytes
       * @description This value is returned so that it can be optionally passed to APIs
       *  that write to the Worker Deployment state to ensure that the state
       *  did not change between this API call and a future write.
       */
      readonly conflictToken?: string;
      /**
       * Format: float
       * @description The ramping version percentage before executing this operation.
       */
      readonly previousPercentage?: number;
      /**
       * @description The version that was ramping before executing this operation, in the form
       *  "<deployment_name>.<build_id>". Can also be the `__unversioned__` special value.
       */
      readonly previousVersion?: string;
    };
    readonly SignalExternalWorkflowExecutionFailedEventAttributes: {
      /**
       * Format: enum
       * @enum {string}
       */
      readonly cause?:
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND'
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND'
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED';
      /** @description Deprecated */
      readonly control?: string;
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the workflow which failed the signal.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly SignalExternalWorkflowExecutionInitiatedEventAttributes: {
      /**
       * @description Workers are expected to set this to true if the workflow they are requesting to cancel is
       *  a child of the workflow which issued the request
       */
      readonly childWorkflowOnly?: boolean;
      /** @description Deprecated */
      readonly control?: string;
      readonly header?: components['schemas']['Header'];
      /** @description Serialized arguments to provide to the signal handler */
      readonly input?: components['schemas']['Payloads'];
      /**
       * @description Namespace of the to-be-signalled workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /** @description name/type of the signal to fire in the external workflow */
      readonly signalName?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly SignalWithStartWorkflowExecutionRequest: {
      /** @description Deprecated */
      readonly control?: string;
      /** @description See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      readonly cronSchedule?: string;
      readonly header?: components['schemas']['Header'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Serialized arguments to the workflow. These are passed as arguments to the workflow function. */
      readonly input?: components['schemas']['Payloads'];
      /** @description Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events. */
      readonly links?: readonly components['schemas']['Link'][];
      readonly memo?: components['schemas']['Memo'];
      readonly namespace?: string;
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      /** @description Used to de-dupe signal w/ start requests */
      readonly requestId?: string;
      /** @description Retry policy for the workflow */
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      /** @description Serialized value(s) to provide with the signal */
      readonly signalInput?: components['schemas']['Payloads'];
      /** @description The workflow author-defined name of the signal to send to the workflow */
      readonly signalName?: string;
      /** @description The task queue to start this workflow on, if it will be started */
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /**
       * @description Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
       *  for use by user interfaces to display the fixed as-of-start summary and details of the
       *  workflow.
       */
      readonly userMetadata?: components['schemas']['UserMetadata'];
      /**
       * @description If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
       *  To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
       */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
      /** @description Total workflow execution timeout including retries and continue as new */
      readonly workflowExecutionTimeout?: string;
      readonly workflowId?: string;
      /**
       * Format: enum
       * @description Defines how to resolve a workflow id conflict with a *running* workflow.
       *  The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
       *  Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
       *
       *  See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
       * @enum {string}
       */
      readonly workflowIdConflictPolicy?:
        | 'WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_CONFLICT_POLICY_FAIL'
        | 'WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING'
        | 'WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING';
      /**
       * Format: enum
       * @description Defines whether to allow re-using the workflow id from a previously *closed* workflow.
       *  The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       *
       *  See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
       * @enum {string}
       */
      readonly workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /** @description Timeout of a single workflow run */
      readonly workflowRunTimeout?: string;
      /**
       * @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *  Note that the signal will be delivered with the first workflow task. If the workflow gets
       *  another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
       *  and the rest of the delay period will be ignored, even if that request also had a delay.
       *  Signal via SignalWorkflowExecution will not unblock the workflow.
       */
      readonly workflowStartDelay?: string;
      /** @description Timeout of a single workflow task */
      readonly workflowTaskTimeout?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly SignalWithStartWorkflowExecutionResponse: {
      /** @description The run id of the workflow that was started - or just signaled, if it was already running. */
      readonly runId?: string;
      /** @description If true, a new workflow was started. */
      readonly started?: boolean;
    };
    readonly SignalWorkflowExecutionRequest: {
      /** @description Deprecated */
      readonly control?: string;
      /**
       * @description Headers that are passed with the signal to the processing workflow.
       *  These can include things like auth or tracing tokens.
       */
      readonly header?: components['schemas']['Header'];
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Serialized value(s) to provide with the signal */
      readonly input?: components['schemas']['Payloads'];
      /** @description Links to be associated with the WorkflowExecutionSignaled event. */
      readonly links?: readonly components['schemas']['Link'][];
      readonly namespace?: string;
      /** @description Used to de-dupe sent signals */
      readonly requestId?: string;
      /** @description The workflow author-defined name of the signal to send to the workflow */
      readonly signalName?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    readonly SignalWorkflowExecutionResponse: Record<string, unknown>;
    readonly StartBatchOperationRequest: {
      readonly cancellationOperation?: components['schemas']['BatchOperationCancellation'];
      readonly deletionOperation?: components['schemas']['BatchOperationDeletion'];
      /**
       * @description Executions to apply the batch operation
       *  This field and `visibility_query` are mutually exclusive
       */
      readonly executions?: readonly components['schemas']['WorkflowExecution'][];
      /** @description Job ID defines the unique ID for the batch job */
      readonly jobId?: string;
      /**
       * Format: float
       * @description Limit for the number of operations processed per second within this batch.
       *  Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
       *  overload and minimize potential delays in executing ongoing tasks for user workers.
       *  Note that when no explicit limit is provided, the server will operate according to its limit defined by the
       *  dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
       *  server's configured limit.
       */
      readonly maxOperationsPerSecond?: number;
      /** @description Namespace that contains the batch operation */
      readonly namespace?: string;
      /** @description Reason to perform the batch operation */
      readonly reason?: string;
      readonly resetOperation?: components['schemas']['BatchOperationReset'];
      readonly signalOperation?: components['schemas']['BatchOperationSignal'];
      readonly terminationOperation?: components['schemas']['BatchOperationTermination'];
      readonly unpauseActivitiesOperation?: components['schemas']['BatchOperationUnpauseActivities'];
      readonly updateWorkflowOptionsOperation?: components['schemas']['BatchOperationUpdateWorkflowExecutionOptions'];
      /**
       * @description Visibility query defines the the group of workflow to apply the batch operation
       *  This field and `executions` are mutually exclusive
       */
      readonly visibilityQuery?: string;
    };
    readonly StartBatchOperationResponse: Record<string, unknown>;
    readonly StartChildWorkflowExecutionFailedEventAttributes: {
      /**
       * Format: enum
       * @enum {string}
       */
      readonly cause?:
        | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
        | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS'
        | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND';
      /** @description Deprecated */
      readonly control?: string;
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      readonly initiatedEventId?: string;
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      readonly workflowId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly StartChildWorkflowExecutionInitiatedEventAttributes: {
      /** @description Deprecated */
      readonly control?: string;
      /** @description If this child runs on a cron schedule, it will appear here */
      readonly cronSchedule?: string;
      readonly header?: components['schemas']['Header'];
      /**
       * @description If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
       *  rules of the child's Task Queue will be used to independently assign a Build ID to it.
       */
      readonly inheritBuildId?: boolean;
      readonly input?: components['schemas']['Payloads'];
      readonly memo?: components['schemas']['Memo'];
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      readonly namespace?: string;
      readonly namespaceId?: string;
      /**
       * Format: enum
       * @description Default: PARENT_CLOSE_POLICY_TERMINATE.
       * @enum {string}
       */
      readonly parentClosePolicy?:
        | 'PARENT_CLOSE_POLICY_UNSPECIFIED'
        | 'PARENT_CLOSE_POLICY_TERMINATE'
        | 'PARENT_CLOSE_POLICY_ABANDON'
        | 'PARENT_CLOSE_POLICY_REQUEST_CANCEL';
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      readonly workflowExecutionTimeout?: string;
      readonly workflowId?: string;
      /**
       * Format: enum
       * @description Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       * @enum {string}
       */
      readonly workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /** @description Timeout of a single workflow run. */
      readonly workflowRunTimeout?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
      /** @description Timeout of a single workflow task. */
      readonly workflowTaskTimeout?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly StartWorkflowExecutionRequest: {
      /**
       * @description Callbacks to be called by the server when this workflow reaches a terminal state.
       *  If the workflow continues-as-new, these callbacks will be carried over to the new execution.
       *  Callback addresses must be whitelisted in the server's dynamic configuration.
       */
      readonly completionCallbacks?: readonly components['schemas']['Callback'][];
      /**
       * @description These values will be available as ContinuedFailure and LastCompletionResult in the
       *  WorkflowExecutionStarted event and through SDKs. The are currently only used by the
       *  server itself (for the schedules feature) and are not intended to be exposed in
       *  StartWorkflowExecution.
       */
      readonly continuedFailure?: components['schemas']['Failure'];
      /** @description See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      readonly cronSchedule?: string;
      readonly header?: components['schemas']['Header'];
      /** @description The identity of the client who initiated this request */
      readonly identity?: string;
      /** @description Serialized arguments to the workflow. These are passed as arguments to the workflow function. */
      readonly input?: components['schemas']['Payloads'];
      readonly lastCompletionResult?: components['schemas']['Payloads'];
      /** @description Links to be associated with the workflow. */
      readonly links?: readonly components['schemas']['Link'][];
      readonly memo?: components['schemas']['Memo'];
      readonly namespace?: string;
      /**
       * @description Defines actions to be done to the existing running workflow when the conflict policy
       *  WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
       *  empty object (ie., all options with default value), it won't do anything to the existing
       *  running workflow. If set, it will add a history event to the running workflow.
       */
      readonly onConflictOptions?: components['schemas']['OnConflictOptions'];
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      /**
       * @description Request to get the first workflow task inline in the response bypassing matching service and worker polling.
       *  If set to `true` the caller is expected to have a worker available and capable of processing the task.
       *  The returned task will be marked as started and is expected to be completed by the specified
       *  `workflow_task_timeout`.
       */
      readonly requestEagerExecution?: boolean;
      /** @description A unique identifier for this start request. Typically UUIDv4. */
      readonly requestId?: string;
      /** @description The retry policy for the workflow. Will never exceed `workflow_execution_timeout`. */
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /**
       * @description Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
       *  for use by user interfaces to display the fixed as-of-start summary and details of the
       *  workflow.
       */
      readonly userMetadata?: components['schemas']['UserMetadata'];
      /**
       * @description If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
       *  To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
       */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      readonly workflowExecutionTimeout?: string;
      readonly workflowId?: string;
      /**
       * Format: enum
       * @description Defines how to resolve a workflow id conflict with a *running* workflow.
       *  The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
       *
       *  See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
       * @enum {string}
       */
      readonly workflowIdConflictPolicy?:
        | 'WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_CONFLICT_POLICY_FAIL'
        | 'WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING'
        | 'WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING';
      /**
       * Format: enum
       * @description Defines whether to allow re-using the workflow id from a previously *closed* workflow.
       *  The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       *
       *  See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
       * @enum {string}
       */
      readonly workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /** @description Timeout of a single workflow run. */
      readonly workflowRunTimeout?: string;
      /**
       * @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *  If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
       *  of the delay will be ignored.
       */
      readonly workflowStartDelay?: string;
      /** @description Timeout of a single workflow task. */
      readonly workflowTaskTimeout?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly StartWorkflowExecutionResponse: {
      /**
       * @description When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
       *  return the first workflow task to be eagerly executed.
       *  The caller is expected to have a worker available to process the task.
       */
      readonly eagerWorkflowTask?: components['schemas']['PollWorkflowTaskQueueResponse'];
      /** @description The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING). */
      readonly runId?: string;
      /** @description If true, a new workflow was started. */
      readonly started?: boolean;
    };
    /** @description The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). */
    readonly Status: {
      /**
       * Format: int32
       * @description The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
       */
      readonly code?: number;
      /** @description A list of messages that carry the error details.  There is a common set of message types for APIs to use. */
      readonly details?: readonly components['schemas']['GoogleProtobufAny'][];
      /** @description A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client. */
      readonly message?: string;
    };
    readonly StopBatchOperationRequest: {
      /** @description Identity of the operator */
      readonly identity?: string;
      /** @description Batch job id */
      readonly jobId?: string;
      /** @description Namespace that contains the batch operation */
      readonly namespace?: string;
      /** @description Reason to stop a batch operation */
      readonly reason?: string;
    };
    readonly StopBatchOperationResponse: Record<string, unknown>;
    /**
     * @description StructuredCalendarSpec describes an event specification relative to the
     *  calendar, in a form that's easy to work with programmatically. Each field can
     *  be one or more ranges.
     *  A timestamp matches if at least one range of each field matches the
     *  corresponding fields of the timestamp, except for year: if year is missing,
     *  that means all years match. For all fields besides year, at least one Range
     *  must be present to match anything.
     *  TODO: add relative-to-end-of-month
     *  TODO: add nth day-of-week in month
     */
    readonly StructuredCalendarSpec: {
      /** @description Free-form comment describing the intention of this spec. */
      readonly comment?: string;
      /**
       * @description Match days of the month (1-31)
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: standard name of field --)
       */
      readonly dayOfMonth?: readonly components['schemas']['Range'][];
      /** @description Match days of the week (0-6; 0 is Sunday). */
      readonly dayOfWeek?: readonly components['schemas']['Range'][];
      /** @description Match hours (0-23) */
      readonly hour?: readonly components['schemas']['Range'][];
      /** @description Match minutes (0-59) */
      readonly minute?: readonly components['schemas']['Range'][];
      /** @description Match months (1-12) */
      readonly month?: readonly components['schemas']['Range'][];
      /** @description Match seconds (0-59) */
      readonly second?: readonly components['schemas']['Range'][];
      /** @description Match years. */
      readonly year?: readonly components['schemas']['Range'][];
    };
    readonly TaskIdBlock: {
      readonly endId?: string;
      readonly startId?: string;
    };
    /** @description See https://docs.temporal.io/docs/concepts/task-queues/ */
    readonly TaskQueue: {
      /**
       * Format: enum
       * @description Default: TASK_QUEUE_KIND_NORMAL.
       * @enum {string}
       */
      readonly kind?:
        | 'TASK_QUEUE_KIND_UNSPECIFIED'
        | 'TASK_QUEUE_KIND_NORMAL'
        | 'TASK_QUEUE_KIND_STICKY';
      readonly name?: string;
      /**
       * @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
       *  the normal task queue that the sticky worker is running on.
       */
      readonly normalName?: string;
    };
    /** @description Reachability of tasks for a worker on a single task queue. */
    readonly TaskQueueReachability: {
      /**
       * @description Task reachability for a worker in a single task queue.
       *  See the TaskReachability docstring for information about each enum variant.
       *  If reachability is empty, this worker is considered unreachable in this task queue.
       */
      readonly reachability?: readonly (
        | 'TASK_REACHABILITY_UNSPECIFIED'
        | 'TASK_REACHABILITY_NEW_WORKFLOWS'
        | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
        | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
        | 'TASK_REACHABILITY_CLOSED_WORKFLOWS'
      )[];
      readonly taskQueue?: string;
    };
    /**
     * @description TaskQueueStats contains statistics about task queue backlog and activity.
     *
     *  For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
     *  comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy.
     */
    readonly TaskQueueStats: {
      /**
       * @description Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
       *  the queue. Can be relied upon for scaling decisions.
       *
       *  Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
       *  those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
       *  few seconds.
       */
      readonly approximateBacklogAge?: string;
      /**
       * @description The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
       *  converges to the right value. Can be relied upon for scaling decisions.
       *
       *  Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
       *  those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
       *  grows.
       */
      readonly approximateBacklogCount?: string;
      /**
       * Format: float
       * @description The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
       *  whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
       *  to the backlog (sync-matched).
       *
       *  The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
       *  backlog grows/shrinks.
       *
       *  Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
       *  tasks_add_rate, because:
       *  - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
       *    enable for activities by default in the latest SDKs.
       *  - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
       *    workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
       *    worker instance.
       */
      readonly tasksAddRate?: number;
      /**
       * Format: float
       * @description The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
       *  tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
       *  going to the backlog (sync-matched).
       *
       *  The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
       *  backlog grows/shrinks.
       *
       *  Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
       *  tasks_dispatch_rate, because:
       *  - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
       *    enable for activities by default in the latest SDKs.
       *  - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
       *    workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
       *    worker instance.
       */
      readonly tasksDispatchRate?: number;
    };
    /** @description Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior. */
    readonly TaskQueueStatus: {
      readonly ackLevel?: string;
      readonly backlogCountHint?: string;
      /** Format: double */
      readonly ratePerSecond?: number;
      readonly readLevel?: string;
      readonly taskIdBlock?: components['schemas']['TaskIdBlock'];
    };
    readonly TaskQueueTypeInfo: {
      /** @description Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID. */
      readonly pollers?: readonly components['schemas']['PollerInfo'][];
      readonly stats?: components['schemas']['TaskQueueStats'];
    };
    readonly TaskQueueVersionInfo: {
      /**
       * Format: enum
       * @description Task Reachability is eventually consistent; there may be a delay until it converges to the most
       *  accurate value but it is designed in a way to take the more conservative side until it converges.
       *  For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
       *
       *  Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
       *  accounted for reachability as server cannot know if they'll happen as they do not use
       *  assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
       *  who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
       *  sure to query reachability for the parent/previous workflow's Task Queue as well.
       * @enum {string}
       */
      readonly taskReachability?:
        | 'BUILD_ID_TASK_REACHABILITY_UNSPECIFIED'
        | 'BUILD_ID_TASK_REACHABILITY_REACHABLE'
        | 'BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY'
        | 'BUILD_ID_TASK_REACHABILITY_UNREACHABLE';
      /** @description Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum. */
      readonly typesInfo?: {
        [key: string]: components['schemas']['TaskQueueTypeInfo'];
      };
    };
    /** @description Experimental. Worker Deployments are experimental and might significantly change in the future. */
    readonly TaskQueueVersioningInfo: {
      /**
       * @description Always present. Specifies which Deployment Version should receive new workflow
       *  executions and tasks of existing unversioned or AutoUpgrade workflows.
       *  Can be one of the following:
       *  - A Deployment Version identifier in the form "<deployment_name>.<build_id>".
       *  - Or, the "__unversioned__" special value, to represent all the unversioned workers (those
       *    with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
       *  Note: Current Version is overridden by the Ramping Version for a portion of traffic when a ramp
       *  is set (see `ramping_version`.)
       */
      readonly currentVersion?: string;
      /**
       * @description When present, it means the traffic is being shifted from the Current Version to the Ramping
       *  Version.
       *  Must always be different from `current_version`. Can be one of the following:
       *  - A Deployment Version identifier in the form "<deployment_name>.<build_id>".
       *  - Or, the "__unversioned__" special value, to represent all the unversioned workers (those
       *    with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
       *  Note that it is possible to ramp from one Version to another Version, or from unversioned
       *  workers to a particular Version, or from a particular Version to unversioned workers.
       */
      readonly rampingVersion?: string;
      /**
       * Format: float
       * @description Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
       *  Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
       *  not yet "promoted" to be the Current Version, likely due to pending validations.
       */
      readonly rampingVersionPercentage?: number;
      /**
       * Format: date-time
       * @description Last time versioning information of this Task Queue changed.
       */
      readonly updateTime?: string;
    };
    readonly TerminatedFailureInfo: Record<string, unknown>;
    readonly TerminateWorkflowExecutionRequest: {
      /** @description Serialized additional information to attach to the termination event */
      readonly details?: components['schemas']['Payloads'];
      /**
       * @description If set, this call will error if the most recent (if no run id is set on
       *  `workflow_execution`), or specified (if it is) workflow execution is not part of the same
       *  execution chain as this id.
       */
      readonly firstExecutionRunId?: string;
      /** @description The identity of the worker/client */
      readonly identity?: string;
      /** @description Links to be associated with the WorkflowExecutionTerminated event. */
      readonly links?: readonly components['schemas']['Link'][];
      readonly namespace?: string;
      readonly reason?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    readonly TerminateWorkflowExecutionResponse: Record<string, unknown>;
    readonly TimeoutFailureInfo: {
      readonly lastHeartbeatDetails?: components['schemas']['Payloads'];
      /**
       * Format: enum
       * @enum {string}
       */
      readonly timeoutType?:
        | 'TIMEOUT_TYPE_UNSPECIFIED'
        | 'TIMEOUT_TYPE_START_TO_CLOSE'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_START'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_CLOSE'
        | 'TIMEOUT_TYPE_HEARTBEAT';
    };
    readonly TimerCanceledEventAttributes: {
      /** @description The id of the worker who requested this cancel */
      readonly identity?: string;
      /** @description The id of the `TIMER_STARTED` event itself */
      readonly startedEventId?: string;
      /** @description Will match the `timer_id` from `TIMER_STARTED` event for this timer */
      readonly timerId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly TimerFiredEventAttributes: {
      /** @description The id of the `TIMER_STARTED` event itself */
      readonly startedEventId?: string;
      /** @description Will match the `timer_id` from `TIMER_STARTED` event for this timer */
      readonly timerId?: string;
    };
    readonly TimerStartedEventAttributes: {
      /**
       * @description How long until this timer fires
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly startToFireTimeout?: string;
      /** @description The worker/user assigned id for this timer */
      readonly timerId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly TimestampedBuildIdAssignmentRule: {
      /** Format: date-time */
      readonly createTime?: string;
      readonly rule?: components['schemas']['BuildIdAssignmentRule'];
    };
    readonly TimestampedCompatibleBuildIdRedirectRule: {
      /** Format: date-time */
      readonly createTime?: string;
      readonly rule?: components['schemas']['CompatibleBuildIdRedirectRule'];
    };
    readonly TriggerImmediatelyRequest: {
      /**
       * Format: enum
       * @description If set, override overlap policy for this one request.
       * @enum {string}
       */
      readonly overlapPolicy?:
        | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
        | 'SCHEDULE_OVERLAP_POLICY_SKIP'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
        | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
    };
    readonly TriggerWorkflowRuleRequest: {
      /** @description Execution info of the workflow which scheduled this activity */
      readonly execution?: components['schemas']['WorkflowExecution'];
      readonly id?: string;
      readonly namespace?: string;
      /** @description Note: Rule ID and expiration date are not used in the trigger request. */
      readonly spec?: components['schemas']['WorkflowRuleSpec'];
    };
    readonly TriggerWorkflowRuleResponse: {
      /** @description True is the rule was applied, based on the rule conditions (predicate/visibility_query). */
      readonly applied?: boolean;
    };
    readonly UnpauseActivityRequest: {
      /** @description Execution info of the workflow which scheduled this activity */
      readonly execution?: components['schemas']['WorkflowExecution'];
      /** @description Only the activity with this ID will be unpaused. */
      readonly id?: string;
      /** @description The identity of the client who initiated this request. */
      readonly identity?: string;
      /** @description If set, the activity will start at a random time within the specified jitter duration. */
      readonly jitter?: string;
      /** @description Namespace of the workflow which scheduled this activity. */
      readonly namespace?: string;
      /** @description Providing this flag will also reset the number of attempts. */
      readonly resetAttempts?: boolean;
      /** @description Providing this flag will also reset the heartbeat details. */
      readonly resetHeartbeat?: boolean;
      /** @description Unpause all running activities with of this type. */
      readonly type?: string;
      /** @description Unpause all running activities. */
      readonly unpauseAll?: boolean;
    };
    readonly UnpauseActivityResponse: Record<string, unknown>;
    readonly UpdateActivityOptionsRequest: {
      /** @description Activity options. Partial updates are accepted and controlled by update_mask */
      readonly activityOptions?: components['schemas']['ActivityOptions'];
      /** @description Execution info of the workflow which scheduled this activity */
      readonly execution?: components['schemas']['WorkflowExecution'];
      /** @description Only activity with this ID will be updated. */
      readonly id?: string;
      /** @description The identity of the client who initiated this request */
      readonly identity?: string;
      /** @description Namespace of the workflow which scheduled this activity */
      readonly namespace?: string;
      /** @description Update all running activities of this type. */
      readonly type?: string;
      /**
       * Format: field-mask
       * @description Controls which fields from `activity_options` will be applied
       */
      readonly updateMask?: string;
    };
    readonly UpdateActivityOptionsResponse: {
      /** @description Activity options after an update */
      readonly activityOptions?: components['schemas']['ActivityOptions'];
    };
    /**
     * @description Used as part of Deployment write APIs to update metadata attached to a deployment.
     *  Deprecated.
     */
    readonly UpdateDeploymentMetadata: {
      /** @description List of keys to remove from the metadata. */
      readonly removeEntries?: readonly string[];
      readonly upsertEntries?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    readonly UpdateNamespaceInfo: {
      /**
       * @description A key-value map for any customized purpose.
       *  If data already exists on the namespace,
       *  this will merge with the existing key values.
       */
      readonly data?: {
        [key: string]: string;
      };
      readonly description?: string;
      readonly ownerEmail?: string;
      /**
       * Format: enum
       * @description New namespace state, server will reject if transition is not allowed.
       *  Allowed transitions are:
       *   Registered -> [ Deleted | Deprecated | Handover ]
       *   Handover -> [ Registered ]
       *  Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
       * @enum {string}
       */
      readonly state?:
        | 'NAMESPACE_STATE_UNSPECIFIED'
        | 'NAMESPACE_STATE_REGISTERED'
        | 'NAMESPACE_STATE_DEPRECATED'
        | 'NAMESPACE_STATE_DELETED';
    };
    readonly UpdateNamespaceRequest: {
      readonly config?: components['schemas']['NamespaceConfig'];
      readonly deleteBadBinary?: string;
      readonly namespace?: string;
      /** @description promote local namespace to global namespace. Ignored if namespace is already global namespace. */
      readonly promoteNamespace?: boolean;
      readonly replicationConfig?: components['schemas']['NamespaceReplicationConfig'];
      readonly securityToken?: string;
      readonly updateInfo?: components['schemas']['UpdateNamespaceInfo'];
    };
    readonly UpdateNamespaceResponse: {
      readonly config?: components['schemas']['NamespaceConfig'];
      readonly failoverVersion?: string;
      readonly isGlobalNamespace?: boolean;
      readonly namespaceInfo?: components['schemas']['NamespaceInfo'];
      readonly replicationConfig?: components['schemas']['NamespaceReplicationConfig'];
    };
    readonly UpdateNexusEndpointRequest: {
      /** @description Server-generated unique endpoint ID. */
      readonly id?: string;
      readonly spec?: components['schemas']['EndpointSpec'];
      /** @description Data version for this endpoint. Must match current version. */
      readonly version?: string;
    };
    readonly UpdateNexusEndpointResponse: {
      /** @description Data post acceptance. Can be used to issue additional updates to this record. */
      readonly endpoint?: components['schemas']['Endpoint'];
    };
    /** @description The data needed by a client to refer to a previously invoked Workflow Update. */
    readonly UpdateRef: {
      readonly updateId?: string;
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    readonly UpdateScheduleRequest: {
      /**
       * Format: bytes
       * @description This can be the value of conflict_token from a DescribeScheduleResponse,
       *  which will cause this request to fail if the schedule has been modified
       *  between the Describe and this Update.
       *  If missing, the schedule will be updated unconditionally.
       */
      readonly conflictToken?: string;
      /** @description The identity of the client who initiated this request. */
      readonly identity?: string;
      /** @description The namespace of the schedule to update. */
      readonly namespace?: string;
      /** @description A unique identifier for this update request for idempotence. Typically UUIDv4. */
      readonly requestId?: string;
      /**
       * @description The new schedule. The four main fields of the schedule (spec, action,
       *  policies, state) are replaced completely by the values in this message.
       */
      readonly schedule?: components['schemas']['Schedule'];
      /** @description The id of the schedule to update. */
      readonly scheduleId?: string;
      /**
       * @description Schedule search attributes to be updated.
       *  Do not set this field if you do not want to update the search attributes.
       *  A non-null empty object will set the search attributes to an empty map.
       *  Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
       *  you must also set the `schedule` field; otherwise, it will unset the schedule.
       */
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
    };
    readonly UpdateScheduleResponse: Record<string, unknown>;
    /** @description Used to update the user-defined metadata of a Worker Deployment Version. */
    readonly UpdateWorkerDeploymentVersionMetadataRequest: {
      readonly namespace?: string;
      /** @description List of keys to remove from the metadata. */
      readonly removeEntries?: readonly string[];
      readonly upsertEntries?: {
        [key: string]: components['schemas']['Payload'];
      };
      /** @description Deployment Version identifier in the form "<deployment_name>.<build_id>". */
      readonly version?: string;
    };
    readonly UpdateWorkerDeploymentVersionMetadataResponse: {
      /** @description Full metadata after performing the update. */
      readonly metadata?: components['schemas']['VersionMetadata'];
    };
    readonly UpdateWorkflowExecutionOptionsRequest: {
      /** @description The namespace name of the target Workflow. */
      readonly namespace?: string;
      /**
       * Format: field-mask
       * @description Controls which fields from `workflow_execution_options` will be applied.
       *  To unset a field, set it to null and use the update mask to indicate that it should be mutated.
       */
      readonly updateMask?: string;
      /**
       * @description The target Workflow Id and (optionally) a specific Run Id thereof.
       *  (-- api-linter: core::0203::optional=disabled
       *      aip.dev/not-precedent: false positive triggered by the word "optional" --)
       */
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description Workflow Execution options. Partial updates are accepted and controlled by update_mask. */
      readonly workflowExecutionOptions?: components['schemas']['WorkflowExecutionOptions'];
    };
    readonly UpdateWorkflowExecutionOptionsResponse: {
      /** @description Workflow Execution options after update. */
      readonly workflowExecutionOptions?: components['schemas']['WorkflowExecutionOptions'];
    };
    /**
     * @description (-- api-linter: core::0134=disabled
     *      aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
     */
    readonly UpdateWorkflowExecutionRequest: {
      /**
       * @description If set, this call will error if the most recent (if no Run Id is set on
       *  `workflow_execution`), or specified (if it is) Workflow Execution is not
       *  part of the same execution chain as this Id.
       */
      readonly firstExecutionRunId?: string;
      /** @description The namespace name of the target Workflow. */
      readonly namespace?: string;
      /**
       * @description The request information that will be delivered all the way down to the
       *  Workflow Execution.
       */
      readonly request?: components['schemas']['Request'];
      /**
       * @description Specifies client's intent to wait for Update results.
       *  NOTE: This field works together with API call timeout which is limited by
       *  server timeout (maximum wait time). If server timeout is expired before
       *  user specified timeout, API call returns even if specified stage is not reached.
       *  Actual reached stage will be included in the response.
       */
      readonly waitPolicy?: components['schemas']['WaitPolicy'];
      /**
       * @description The target Workflow Id and (optionally) a specific Run Id thereof.
       *  (-- api-linter: core::0203::optional=disabled
       *      aip.dev/not-precedent: false positive triggered by the word "optional" --)
       */
      readonly workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    readonly UpdateWorkflowExecutionResponse: {
      /**
       * @description The outcome of the Update if and only if the Workflow Update
       *  has completed. If this response is being returned before the Update has
       *  completed then this field will not be set.
       */
      readonly outcome?: components['schemas']['Outcome'];
      /**
       * Format: enum
       * @description The most advanced lifecycle stage that the Update is known to have
       *  reached, where lifecycle stages are ordered
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
       *  UNSPECIFIED will be returned if and only if the server's maximum wait
       *  time was reached before the Update reached the stage specified in the
       *  request WaitPolicy, and before the context deadline expired; clients may
       *  may then retry the call as needed.
       * @enum {string}
       */
      readonly stage?:
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED';
      /** @description Enough information for subsequent poll calls if needed. Never null. */
      readonly updateRef?: components['schemas']['UpdateRef'];
    };
    readonly UpsertWorkflowSearchAttributesEventAttributes: {
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    /** @description Information a user can set, often for use by user interfaces. */
    readonly UserMetadata: {
      /**
       * @description Long-form text that provides details. This payload should be a "json/plain"-encoded payload
       *  that is a single JSON string for use in user interfaces. User interface formatting may apply to
       *  this text in common use. The payload data section is limited to 20000 bytes by default.
       */
      readonly details?: components['schemas']['Payload'];
      /**
       * @description Short-form text that provides a summary. This payload should be a "json/plain"-encoded payload
       *  that is a single JSON string for use in user interfaces. User interface formatting may not
       *  apply to this text when used in "title" situations. The payload data section is limited to 400
       *  bytes by default.
       */
      readonly summary?: components['schemas']['Payload'];
    };
    /**
     * @description Information about workflow drainage to help the user determine when it is safe
     *  to decommission a Version. Not present while version is current or ramping.
     *  Experimental. Worker Deployments are experimental and might significantly change in the future.
     */
    readonly VersionDrainageInfo: {
      /**
       * Format: date-time
       * @description Last time the drainage status changed.
       */
      readonly lastChangedTime?: string;
      /**
       * Format: date-time
       * @description Last time the system checked for drainage of this version.
       */
      readonly lastCheckedTime?: string;
      /**
       * Format: enum
       * @description Set to DRAINING when the version first stops accepting new executions (is no longer current or ramping).
       *  Set to DRAINED when no more open pinned workflows exist on this version.
       * @enum {string}
       */
      readonly status?:
        | 'VERSION_DRAINAGE_STATUS_UNSPECIFIED'
        | 'VERSION_DRAINAGE_STATUS_DRAINING'
        | 'VERSION_DRAINAGE_STATUS_DRAINED';
    };
    /** @description VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions. */
    readonly VersionInfo: {
      readonly alerts?: readonly components['schemas']['Alert'][];
      readonly current?: components['schemas']['ReleaseInfo'];
      readonly instructions?: string;
      /** Format: date-time */
      readonly lastUpdateTime?: string;
      readonly recommended?: components['schemas']['ReleaseInfo'];
    };
    /**
     * @description Used to override the versioning behavior (and pinned deployment version, if applicable) of a
     *  specific workflow execution. If set, takes precedence over the worker-sent values. See
     *  `WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call
     *  `UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`
     *  to indicate that it should be mutated.
     */
    readonly VersioningOverride: {
      /**
       * Format: enum
       * @description Required.
       * @enum {string}
       */
      readonly behavior?:
        | 'VERSIONING_BEHAVIOR_UNSPECIFIED'
        | 'VERSIONING_BEHAVIOR_PINNED'
        | 'VERSIONING_BEHAVIOR_AUTO_UPGRADE';
      /**
       * @description Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
       *  Identifies the worker deployment to pin the workflow to.
       *  Deprecated. Use `pinned_version`.
       */
      readonly deployment?: components['schemas']['Deployment'];
      /**
       * @description Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
       *  Identifies the worker deployment version to pin the workflow to, in the format
       *  "<deployment_name>.<build_id>".
       */
      readonly pinnedVersion?: string;
    };
    readonly VersionMetadata: {
      /** @description Arbitrary key-values. */
      readonly entries?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    /** @description Specifies client's intent to wait for Update results. */
    readonly WaitPolicy: {
      /**
       * Format: enum
       * @description Indicates the Update lifecycle stage that the Update must reach before
       *  API call is returned.
       *  NOTE: This field works together with API call timeout which is limited by
       *  server timeout (maximum wait time). If server timeout is expired before
       *  user specified timeout, API call returns even if specified stage is not reached.
       * @enum {string}
       */
      readonly lifecycleStage?:
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED';
    };
    /**
     * @description A Worker Deployment (Deployment, for short) represents all workers serving
     *  a shared set of Task Queues. Typically, a Deployment represents one service or
     *  application.
     *  A Deployment contains multiple Deployment Versions, each representing a different
     *  version of workers. (see documentation of WorkerDeploymentVersionInfo)
     *  Deployment records are created in Temporal server automatically when their
     *  first poller arrives to the server.
     *  Experimental. Worker Deployments are experimental and might significantly change in the future.
     */
    readonly WorkerDeploymentInfo: {
      /** Format: date-time */
      readonly createTime?: string;
      /**
       * @description Identity of the last client who modified the configuration of this Deployment. Set to the
       *  `identity` value sent by APIs such as `SetWorkerDeploymentCurrentVersion` and
       *  `SetWorkerDeploymentRampingVersion`.
       */
      readonly lastModifierIdentity?: string;
      /** @description Identifies a Worker Deployment. Must be unique within the namespace. */
      readonly name?: string;
      readonly routingConfig?: components['schemas']['RoutingConfig'];
      /**
       * @description Deployment Versions that are currently tracked in this Deployment. A DeploymentVersion will be
       *  cleaned up automatically if all the following conditions meet:
       *  - It does not receive new executions (is not current or ramping)
       *  - It has no active pollers (see WorkerDeploymentVersionInfo.pollers_status)
       *  - It is drained (see WorkerDeploymentVersionInfo.drainage_status)
       */
      readonly versionSummaries?: readonly components['schemas']['WorkerDeploymentInfo_WorkerDeploymentVersionSummary'][];
    };
    readonly WorkerDeploymentInfo_WorkerDeploymentVersionSummary: {
      /** Format: date-time */
      readonly createTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly drainageStatus?:
        | 'VERSION_DRAINAGE_STATUS_UNSPECIFIED'
        | 'VERSION_DRAINAGE_STATUS_DRAINING'
        | 'VERSION_DRAINAGE_STATUS_DRAINED';
      /** @description The fully-qualified string representation of the version, in the form "<deployment_name>.<build_id>". */
      readonly version?: string;
    };
    /**
     * @description Worker Deployment options set in SDK that need to be sent to server in every poll.
     *  Experimental. Worker Deployments are experimental and might significantly change in the future.
     */
    readonly WorkerDeploymentOptions: {
      /**
       * @description The Build ID of the worker. Required when `worker_versioning_mode==VERSIONED`, in which case,
       *  the worker will be part of a Deployment Version identified by "<deployment_name>.<build_id>".
       */
      readonly buildId?: string;
      /** @description Required. Worker Deployment name. */
      readonly deploymentName?: string;
      /**
       * Format: enum
       * @description Required. Versioning Mode for this worker. Must be the same for all workers with the
       *  same `deployment_name` and `build_id` combination, across all Task Queues.
       *  When `worker_versioning_mode==VERSIONED`, the worker will be part of a Deployment Version
       *  identified by "<deployment_name>.<build_id>".
       * @enum {string}
       */
      readonly workerVersioningMode?:
        | 'WORKER_VERSIONING_MODE_UNSPECIFIED'
        | 'WORKER_VERSIONING_MODE_UNVERSIONED'
        | 'WORKER_VERSIONING_MODE_VERSIONED';
    };
    /**
     * @description A Worker Deployment Version (Version, for short) represents all workers of the same
     *  code and config within a Deployment. Workers of the same Version are expected to
     *  behave exactly the same so when executions move between them there are no
     *  non-determinism issues.
     *  Worker Deployment Versions are created in Temporal server automatically when
     *  their first poller arrives to the server.
     *  Experimental. Worker Deployments are experimental and might significantly change in the future.
     */
    readonly WorkerDeploymentVersionInfo: {
      /** Format: date-time */
      readonly createTime?: string;
      /**
       * Format: date-time
       * @description (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
       *  Nil if not current.
       */
      readonly currentSinceTime?: string;
      readonly deploymentName?: string;
      /**
       * @description Helps user determine when it is safe to decommission the workers of this
       *  Version. Not present when version is current or ramping.
       *  Current limitations:
       *  - Not supported for Unversioned mode.
       *  - Periodically refreshed, may have delays up to few minutes (consult the
       *    last_checked_time value).
       *  - Refreshed only when version is not current or ramping AND the status is not
       *    "drained" yet.
       *  - Once the status is changed to "drained", it is not changed until the Version
       *    becomes Current or Ramping again, at which time the drainage info is cleared.
       *    This means if the Version is "drained" but new workflows are sent to it via
       *    Pinned Versioning Override, the status does not account for those Pinned-override
       *    executions and remains "drained".
       */
      readonly drainageInfo?: components['schemas']['VersionDrainageInfo'];
      /** @description Arbitrary user-provided metadata attached to this version. */
      readonly metadata?: components['schemas']['VersionMetadata'];
      /**
       * Format: date-time
       * @description (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
       *  Nil if not ramping. Updated when the version first starts ramping, not on each ramp change.
       */
      readonly rampingSinceTime?: string;
      /**
       * Format: float
       * @description Range: [0, 100]. Must be zero if the version is not ramping (i.e. `ramping_since_time` is nil).
       *  Can be in the range [0, 100] if the version is ramping.
       */
      readonly rampPercentage?: number;
      /**
       * Format: date-time
       * @description Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
       */
      readonly routingChangedTime?: string;
      /** @description All the Task Queues that have ever polled from this Deployment version. */
      readonly taskQueueInfos?: readonly components['schemas']['WorkerDeploymentVersionInfo_VersionTaskQueueInfo'][];
      /** @description The fully-qualified string representation of the version, in the form "<deployment_name>.<build_id>". */
      readonly version?: string;
    };
    readonly WorkerDeploymentVersionInfo_VersionTaskQueueInfo: {
      readonly name?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly type?:
        | 'TASK_QUEUE_TYPE_UNSPECIFIED'
        | 'TASK_QUEUE_TYPE_WORKFLOW'
        | 'TASK_QUEUE_TYPE_ACTIVITY'
        | 'TASK_QUEUE_TYPE_NEXUS';
    };
    /**
     * @description Identifies the version that a worker is compatible with when polling or identifying itself,
     *  and whether or not this worker is opting into the build-id based versioning feature. This is
     *  used by matching to determine which workers ought to receive what tasks.
     *  Deprecated. Use WorkerDeploymentOptions instead.
     */
    readonly WorkerVersionCapabilities: {
      /** @description An opaque whole-worker identifier */
      readonly buildId?: string;
      /** @description Must be sent if user has set a deployment series name (versioning-3). */
      readonly deploymentSeriesName?: string;
      /**
       * @description If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
       *  tasks.
       */
      readonly useVersioning?: boolean;
    };
    /**
     * @description Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.
     *  Identifies the version(s) of a worker that processed a task
     */
    readonly WorkerVersionStamp: {
      /**
       * @description An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
       *  message is included in requests which previously used that.
       */
      readonly buildId?: string;
      /**
       * @description If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
       *  marker for workflow reset points and the BuildIDs search attribute.
       */
      readonly useVersioning?: boolean;
    };
    readonly WorkflowEvent_EventReference: {
      readonly eventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly eventType?:
        | 'EVENT_TYPE_UNSPECIFIED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_STARTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT'
        | 'EVENT_TYPE_WORKFLOW_TASK_SCHEDULED'
        | 'EVENT_TYPE_WORKFLOW_TASK_STARTED'
        | 'EVENT_TYPE_WORKFLOW_TASK_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT'
        | 'EVENT_TYPE_WORKFLOW_TASK_FAILED'
        | 'EVENT_TYPE_ACTIVITY_TASK_SCHEDULED'
        | 'EVENT_TYPE_ACTIVITY_TASK_STARTED'
        | 'EVENT_TYPE_ACTIVITY_TASK_COMPLETED'
        | 'EVENT_TYPE_ACTIVITY_TASK_FAILED'
        | 'EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT'
        | 'EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED'
        | 'EVENT_TYPE_ACTIVITY_TASK_CANCELED'
        | 'EVENT_TYPE_TIMER_STARTED'
        | 'EVENT_TYPE_TIMER_FIRED'
        | 'EVENT_TYPE_TIMER_CANCELED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED'
        | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_MARKER_RECORDED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW'
        | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED'
        | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED'
        | 'EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY'
        | 'EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY'
        | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED'
        | 'EVENT_TYPE_NEXUS_OPERATION_SCHEDULED'
        | 'EVENT_TYPE_NEXUS_OPERATION_STARTED'
        | 'EVENT_TYPE_NEXUS_OPERATION_COMPLETED'
        | 'EVENT_TYPE_NEXUS_OPERATION_FAILED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCELED'
        | 'EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED';
    };
    /**
     * @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
     *  uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
     *  run id as a way of saying "target the latest run of the workflow".
     */
    readonly WorkflowExecution: {
      readonly runId?: string;
      readonly workflowId?: string;
    };
    readonly WorkflowExecutionCanceledEventAttributes: {
      readonly details?: components['schemas']['Payloads'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly WorkflowExecutionCancelRequestedEventAttributes: {
      /**
       * @description User provided reason for requesting cancellation
       *  TODO: shall we create a new field with name "reason" and deprecate this one?
       */
      readonly cause?: string;
      /** @description TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one? */
      readonly externalInitiatedEventId?: string;
      readonly externalWorkflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description id of the worker or client who requested this cancel */
      readonly identity?: string;
    };
    readonly WorkflowExecutionCompletedEventAttributes: {
      /** @description If another run is started by cron, this contains the new run id. */
      readonly newExecutionRunId?: string;
      /** @description Serialized result of workflow completion (ie: The return value of the workflow function) */
      readonly result?: components['schemas']['Payloads'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    readonly WorkflowExecutionConfig: {
      readonly defaultWorkflowTaskTimeout?: string;
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /** @description User metadata provided on start workflow. */
      readonly userMetadata?: components['schemas']['UserMetadata'];
      readonly workflowExecutionTimeout?: string;
      readonly workflowRunTimeout?: string;
    };
    readonly WorkflowExecutionContinuedAsNewEventAttributes: {
      /** @description TODO: How and is this used? */
      readonly backoffStartInterval?: string;
      /**
       * @description TODO: David are these right?
       *  Deprecated. If a workflow's retry policy would cause a new run to start when the current one
       *  has failed, this field would be populated with that failure. Now (when supported by server
       *  and sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set.
       */
      readonly failure?: components['schemas']['Failure'];
      readonly header?: components['schemas']['Header'];
      /**
       * @description If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
       *  the assignment rules will be used to independently assign a Build ID to the new execution.
       */
      readonly inheritBuildId?: boolean;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly initiator?:
        | 'CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED'
        | 'CONTINUE_AS_NEW_INITIATOR_WORKFLOW'
        | 'CONTINUE_AS_NEW_INITIATOR_RETRY'
        | 'CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE';
      readonly input?: components['schemas']['Payloads'];
      /** @description TODO: Is this the result of *this* workflow as it continued-as-new? */
      readonly lastCompletionResult?: components['schemas']['Payloads'];
      readonly memo?: components['schemas']['Memo'];
      /** @description The run ID of the new workflow started by this continue-as-new */
      readonly newExecutionRunId?: string;
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /** @description Timeout of a single workflow run. */
      readonly workflowRunTimeout?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
      /** @description Timeout of a single workflow task. */
      readonly workflowTaskTimeout?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    /** @description Holds all the extra information about workflow execution that is not part of Visibility. */
    readonly WorkflowExecutionExtendedInfo: {
      /** @description indicates if the workflow received a cancel request */
      readonly cancelRequested?: boolean;
      /**
       * Format: date-time
       * @description Workflow execution expiration time is defined as workflow start time plus expiration timeout.
       *  Workflow start time may change after workflow reset.
       */
      readonly executionExpirationTime?: string;
      /**
       * Format: date-time
       * @description Last workflow reset time. Nil if the workflow was never reset.
       */
      readonly lastResetTime?: string;
      /**
       * Format: date-time
       * @description Original workflow start time.
       */
      readonly originalStartTime?: string;
      /** @description Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run. */
      readonly resetRunId?: string;
      /**
       * Format: date-time
       * @description Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
       */
      readonly runExpirationTime?: string;
    };
    readonly WorkflowExecutionFailedEventAttributes: {
      /** @description Serialized result of workflow failure (ex: An exception thrown, or error returned) */
      readonly failure?: components['schemas']['Failure'];
      /** @description If another run is started by cron or retry, this contains the new run id. */
      readonly newExecutionRunId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    /**
     * @description Hold basic information about a workflow execution.
     *  This structure is a part of visibility, and thus contain a limited subset of information.
     */
    readonly WorkflowExecutionInfo: {
      /**
       * @description The currently assigned build ID for this execution. Presence of this value means worker versioning is used
       *  for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
       *  when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
       *  again, the assigned build ID may change according to the latest versioning rules.
       *  Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
       *  this execution.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly assignedBuildId?: string;
      readonly autoResetPoints?: components['schemas']['ResetPoints'];
      /** Format: date-time */
      readonly closeTime?: string;
      readonly execution?: components['schemas']['WorkflowExecution'];
      /**
       * @description Workflow execution duration is defined as difference between close time and execution time.
       *  This field is only populated if the workflow is closed.
       */
      readonly executionDuration?: string;
      /** Format: date-time */
      readonly executionTime?: string;
      /**
       * @description The first run ID in the execution chain.
       *  Executions created via the following operations are considered to be in the same chain
       *  - ContinueAsNew
       *  - Workflow Retry
       *  - Workflow Reset
       *  - Cron Schedule
       */
      readonly firstRunId?: string;
      readonly historyLength?: string;
      readonly historySizeBytes?: string;
      /**
       * @description Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
       *  of using the assignment rules.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly inheritedBuildId?: string;
      readonly memo?: components['schemas']['Memo'];
      /**
       * @description If set, the most recent worker version stamp that appeared in a workflow task completion
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly mostRecentWorkerVersionStamp?: components['schemas']['WorkerVersionStamp'];
      readonly parentExecution?: components['schemas']['WorkflowExecution'];
      readonly parentNamespaceId?: string;
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      /**
       * @description Contains information about the root workflow execution.
       *  The root workflow execution is defined as follows:
       *  1. A workflow without parent workflow is its own root workflow.
       *  2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
       *  Note: workflows continued as new or reseted may or may not have parents, check examples below.
       *
       *  Examples:
       *    Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 3: Workflow W1 continued as new W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       *    Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
       *      - The root workflow of all three workflows is W1.
       *    Scenario 5: Workflow W1 is reseted, creating W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       */
      readonly rootExecution?: components['schemas']['WorkflowExecution'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      /** Format: date-time */
      readonly startTime?: string;
      readonly stateTransitionCount?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly status?:
        | 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED'
        | 'WORKFLOW_EXECUTION_STATUS_RUNNING'
        | 'WORKFLOW_EXECUTION_STATUS_COMPLETED'
        | 'WORKFLOW_EXECUTION_STATUS_FAILED'
        | 'WORKFLOW_EXECUTION_STATUS_CANCELED'
        | 'WORKFLOW_EXECUTION_STATUS_TERMINATED'
        | 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW'
        | 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT';
      readonly taskQueue?: string;
      readonly type?: components['schemas']['WorkflowType'];
      /**
       * @description Absent value means the workflow execution is not versioned. When present, the execution might
       *  be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
       *  Experimental. Versioning info is experimental and might change in the future.
       */
      readonly versioningInfo?: components['schemas']['WorkflowExecutionVersioningInfo'];
      /**
       * @description The name of Worker Deployment that completed the most recent workflow task.
       *  Experimental. Worker Deployments are experimental and might change in the future.
       */
      readonly workerDeploymentName?: string;
    };
    readonly WorkflowExecutionOptions: {
      /** @description If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion. */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
    };
    readonly WorkflowExecutionOptionsUpdatedEventAttributes: {
      /** @description Completion callbacks attached to the running workflow execution. */
      readonly attachedCompletionCallbacks?: readonly components['schemas']['Callback'][];
      /**
       * @description Request ID attachedto the running workflow execution so that subsequent requests with same
       *  request ID will be deduped.
       */
      readonly attachedRequestId?: string;
      /** @description Versioning override removed in this event. */
      readonly unsetVersioningOverride?: boolean;
      /**
       * @description Versioning override upserted in this event.
       *  Ignored if nil or if unset_versioning_override is true.
       */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
    };
    readonly WorkflowExecutionSignaledEventAttributes: {
      /** @description When signal origin is a workflow execution, this field is set. */
      readonly externalWorkflowExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description Headers that were passed by the sender of the signal and copied by temporal
       *  server into the workflow task.
       */
      readonly header?: components['schemas']['Header'];
      /** @description id of the worker/client who sent this signal */
      readonly identity?: string;
      /** @description Will be deserialized and provided as argument(s) to the signal handler */
      readonly input?: components['schemas']['Payloads'];
      /** @description The name/type of the signal to fire */
      readonly signalName?: string;
      /** @description This field is deprecated and never respected. It should always be set to false. */
      readonly skipGenerateWorkflowTask?: boolean;
    };
    /** @description Always the first event in workflow history */
    readonly WorkflowExecutionStartedEventAttributes: {
      /**
       * Format: int32
       * @description Starting at 1, the number of times we have tried to execute this workflow
       */
      readonly attempt?: number;
      /** @description Completion callbacks attached when this workflow was started. */
      readonly completionCallbacks?: readonly components['schemas']['Callback'][];
      /**
       * @description Run id of the previous workflow which continued-as-new or retired or cron executed into this
       *  workflow.
       */
      readonly continuedExecutionRunId?: string;
      readonly continuedFailure?: components['schemas']['Failure'];
      /** @description If this workflow runs on a cron schedule, it will appear here */
      readonly cronSchedule?: string;
      /**
       * @description This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.
       *  Used to identify a chain.
       */
      readonly firstExecutionRunId?: string;
      /**
       * @description For a cron workflow, this contains the amount of time between when this iteration of
       *  the cron workflow was scheduled and when it should run next per its cron_schedule.
       */
      readonly firstWorkflowTaskBackoff?: string;
      readonly header?: components['schemas']['Header'];
      /** @description Identity of the client who requested this execution */
      readonly identity?: string;
      /**
       * @description When present, this execution is assigned to the build ID of its parent or previous execution.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly inheritedBuildId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly initiator?:
        | 'CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED'
        | 'CONTINUE_AS_NEW_INITIATOR_WORKFLOW'
        | 'CONTINUE_AS_NEW_INITIATOR_RETRY'
        | 'CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE';
      /** @description SDK will deserialize this and provide it as arguments to the workflow function */
      readonly input?: components['schemas']['Payloads'];
      readonly lastCompletionResult?: components['schemas']['Payloads'];
      readonly memo?: components['schemas']['Memo'];
      /**
       * @description This is the run id when the WorkflowExecutionStarted event was written.
       *  A workflow reset changes the execution run_id, but preserves this field.
       */
      readonly originalExecutionRunId?: string;
      /** @description EventID of the child execution initiated event in parent workflow */
      readonly parentInitiatedEventId?: string;
      /**
       * @description Version of the child execution initiated event in parent workflow
       *  It should be used together with parent_initiated_event_id to identify
       *  a child initiated event for global namespace
       */
      readonly parentInitiatedEventVersion?: string;
      /**
       * @description When present, it means this is a child workflow of a parent that is Pinned to this Worker
       *  Deployment Version. In this case, child workflow will start as Pinned to this Version instead
       *  of starting on the Current Version of its Task Queue.
       *  This is set only if the child workflow is starting on a Task Queue belonging to the same
       *  Worker Deployment Version.
       */
      readonly parentPinnedWorkerDeploymentVersion?: string;
      /**
       * @description Contains information about parent workflow execution that initiated the child workflow these attributes belong to.
       *  If the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated.
       */
      readonly parentWorkflowExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description If this workflow is a child, the namespace our parent lives in.
       *  SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only.
       */
      readonly parentWorkflowNamespace?: string;
      readonly parentWorkflowNamespaceId?: string;
      readonly prevAutoResetPoints?: components['schemas']['ResetPoints'];
      /** @description Priority metadata */
      readonly priority?: components['schemas']['Priority'];
      readonly retryPolicy?: components['schemas']['RetryPolicy'];
      /**
       * @description Contains information about the root workflow execution.
       *  The root workflow execution is defined as follows:
       *  1. A workflow without parent workflow is its own root workflow.
       *  2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
       *  Note: workflows continued as new or reseted may or may not have parents, check examples below.
       *
       *  Examples:
       *    Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 3: Workflow W1 continued as new W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       *    Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
       *      - The root workflow of all three workflows is W1.
       *    Scenario 5: Workflow W1 is reseted, creating W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       */
      readonly rootWorkflowExecution?: components['schemas']['WorkflowExecution'];
      readonly searchAttributes?: components['schemas']['SearchAttributes'];
      /**
       * @description If this workflow intends to use anything other than the current overall default version for
       *  the queue, then we include it here.
       *  Deprecated. [cleanup-experimental-wv]
       */
      readonly sourceVersionStamp?: components['schemas']['WorkerVersionStamp'];
      readonly taskQueue?: components['schemas']['TaskQueue'];
      /** @description Versioning override applied to this workflow when it was started. */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
      /**
       * Format: date-time
       * @description The absolute time at which the workflow will be timed out.
       *  This is passed without change to the next run/retry of a workflow.
       */
      readonly workflowExecutionExpirationTime?: string;
      /** @description Total workflow execution timeout including retries and continue as new. */
      readonly workflowExecutionTimeout?: string;
      /** @description This field is new in 1.21. */
      readonly workflowId?: string;
      /** @description Timeout of a single workflow run. */
      readonly workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      readonly workflowTaskTimeout?: string;
      readonly workflowType?: components['schemas']['WorkflowType'];
    };
    readonly WorkflowExecutionTerminatedEventAttributes: {
      readonly details?: components['schemas']['Payloads'];
      /** @description id of the client who requested termination */
      readonly identity?: string;
      /** @description User/client provided reason for termination */
      readonly reason?: string;
    };
    readonly WorkflowExecutionTimedOutEventAttributes: {
      /** @description If another run is started by cron or retry, this contains the new run id. */
      readonly newExecutionRunId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
    };
    readonly WorkflowExecutionUpdateAcceptedEventAttributes: {
      /**
       * @description The message payload of the original request message that initiated this
       *  update.
       */
      readonly acceptedRequest?: components['schemas']['Request'];
      /**
       * @description The message ID of the original request message that initiated this
       *  update. Needed so that the worker can recreate and deliver that same
       *  message as part of replay.
       */
      readonly acceptedRequestMessageId?: string;
      /** @description The event ID used to sequence the original request message. */
      readonly acceptedRequestSequencingEventId?: string;
      /** @description The instance ID of the update protocol that generated this event. */
      readonly protocolInstanceId?: string;
    };
    readonly WorkflowExecutionUpdateAdmittedEventAttributes: {
      /**
       * Format: enum
       * @description An explanation of why this event was written to history.
       * @enum {string}
       */
      readonly origin?:
        | 'UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED'
        | 'UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY';
      /** @description The update request associated with this event. */
      readonly request?: components['schemas']['Request'];
    };
    readonly WorkflowExecutionUpdateCompletedEventAttributes: {
      /** @description The event ID indicating the acceptance of this update. */
      readonly acceptedEventId?: string;
      /** @description The metadata about this update. */
      readonly meta?: components['schemas']['Meta'];
      /** @description The outcome of executing the workflow update function. */
      readonly outcome?: components['schemas']['Outcome'];
    };
    readonly WorkflowExecutionUpdateRejectedEventAttributes: {
      /** @description The cause of rejection. */
      readonly failure?: components['schemas']['Failure'];
      /** @description The instance ID of the update protocol that generated this event. */
      readonly protocolInstanceId?: string;
      /**
       * @description The message payload of the original request message that initiated this
       *  update.
       */
      readonly rejectedRequest?: components['schemas']['Request'];
      /**
       * @description The message ID of the original request message that initiated this
       *  update. Needed so that the worker can recreate and deliver that same
       *  message as part of replay.
       */
      readonly rejectedRequestMessageId?: string;
      /** @description The event ID used to sequence the original request message. */
      readonly rejectedRequestSequencingEventId?: string;
    };
    /**
     * @description Holds all the information about worker versioning for a particular workflow execution.
     *  Experimental. Versioning info is experimental and might change in the future.
     */
    readonly WorkflowExecutionVersioningInfo: {
      /**
       * Format: enum
       * @description Versioning behavior determines how the server should treat this execution when workers are
       *  upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
       *  unversioned. See the comments in `VersioningBehavior` enum for more info about different
       *  behaviors.
       *  This field is first set after an execution completes its first workflow task on a versioned
       *  worker, and set again on completion of every subsequent workflow task.
       *  For child workflows of Pinned parents, this will be set to Pinned (along with `version`) when
       *  the the child starts so that child's first workflow task goes to the same Version as the
       *  parent. After the first workflow task, it depends on the child workflow itself if it wants
       *  to stay pinned or become unpinned (according to Versioning Behavior set in the worker).
       *  Note that `behavior` is overridden by `versioning_override` if the latter is present.
       * @enum {string}
       */
      readonly behavior?:
        | 'VERSIONING_BEHAVIOR_UNSPECIFIED'
        | 'VERSIONING_BEHAVIOR_PINNED'
        | 'VERSIONING_BEHAVIOR_AUTO_UPGRADE';
      /**
       * @description The worker deployment that completed the last workflow task of this workflow execution. Must
       *  be present if `behavior` is set. Absent value means no workflow task is completed, or the
       *  last workflow task was completed by an unversioned worker. Unversioned workers may still send
       *  a deployment value which will be stored here, so the right way to check if an execution is
       *  versioned if an execution is versioned or not is via the `behavior` field.
       *  Note that `deployment` is overridden by `versioning_override` if the latter is present.
       *  Deprecated. Use `version`.
       */
      readonly deployment?: components['schemas']['Deployment'];
      /**
       * @description When present, indicates the workflow is transitioning to a different deployment. Can
       *  indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
       *  on a different deployment, or versioned -> unversioned.
       *  Not applicable to workflows with PINNED behavior.
       *  When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
       *  start a transition to the task queue's current deployment if the task queue's current
       *  deployment is different from the workflow's deployment.
       *  If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
       *  tasks will be redirected to the task queue's current deployment. As soon as a poller from
       *  that deployment is available to receive the task, the workflow will automatically start a
       *  transition to that deployment and continue execution there.
       *  A deployment transition can only exist while there is a pending or started workflow task.
       *  Once the pending workflow task completes on the transition's target deployment, the
       *  transition completes and the workflow's `deployment` and `behavior` fields are updated per
       *  the worker's task completion response.
       *  Pending activities will not start new attempts during a transition. Once the transition is
       *  completed, pending activities will start their next attempt on the new deployment.
       *  Deprecated. Use version_transition.
       */
      readonly deploymentTransition?: components['schemas']['DeploymentTransition'];
      /**
       * @description The Worker Deployment Version that completed the last workflow task of this workflow
       *  execution, in the form "<deployment_name>.<build_id>".
       *  Must be present if and only if `behavior` is set. An absent value means no workflow task is
       *  completed, or the workflow is unversioned.
       *  For child workflows of Pinned parents, this will be set to parent's Pinned Version when the
       *  the child starts so that child's first workflow task goes to the same Version as the parent.
       *  Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
       *  will override this value.
       */
      readonly version?: string;
      /**
       * @description Present if user has set an execution-specific versioning override. This override takes
       *  precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
       *  override can be set when starting a new execution, as well as afterwards by calling the
       *  `UpdateWorkflowExecutionOptions` API.
       *  Pinned overrides are automatically inherited by child workflows.
       */
      readonly versioningOverride?: components['schemas']['VersioningOverride'];
      /**
       * @description When present, indicates the workflow is transitioning to a different deployment version
       *  (which may belong to the same deployment name or another). Can indicate one of the following
       *  transitions: unversioned -> versioned, versioned -> versioned
       *  on a different deployment version, or versioned -> unversioned.
       *  Not applicable to workflows with PINNED behavior.
       *  When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
       *  start a transition to the task queue's current version if the task queue's current version is
       *  different from the workflow's current deployment version.
       *  If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
       *  tasks will be redirected to the task queue's current version. As soon as a poller from
       *  that deployment version is available to receive the task, the workflow will automatically
       *  start a transition to that version and continue execution there.
       *  A version transition can only exist while there is a pending or started workflow task.
       *  Once the pending workflow task completes on the transition's target version, the
       *  transition completes and the workflow's `behavior`, and `version` fields are updated per the
       *  worker's task completion response.
       *  Pending activities will not start new attempts during a transition. Once the transition is
       *  completed, pending activities will start their next attempt on the new version.
       */
      readonly versionTransition?: components['schemas']['DeploymentVersionTransition'];
    };
    readonly WorkflowPropertiesModifiedEventAttributes: {
      /**
       * @description If set, update the workflow memo with the provided values. The values will be merged with
       *  the existing memo. If the user wants to delete values, a default/empty Payload should be
       *  used as the value for the key being deleted.
       */
      readonly upsertedMemo?: components['schemas']['Memo'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      readonly workflowTaskCompletedEventId?: string;
    };
    /** @description Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes */
    readonly WorkflowPropertiesModifiedExternallyEventAttributes: {
      /** @description Not used. */
      readonly newTaskQueue?: string;
      /** @description Not used. */
      readonly newWorkflowExecutionTimeout?: string;
      /** @description Not used. */
      readonly newWorkflowRunTimeout?: string;
      /** @description Not used. */
      readonly newWorkflowTaskTimeout?: string;
      /** @description Not used. */
      readonly upsertedMemo?: components['schemas']['Memo'];
    };
    /** @description See https://docs.temporal.io/docs/concepts/queries/ */
    readonly WorkflowQuery: {
      /**
       * @description Headers that were passed by the caller of the query and copied by temporal
       *  server into the workflow task.
       */
      readonly header?: components['schemas']['Header'];
      /** @description Serialized arguments that will be provided to the query handler. */
      readonly queryArgs?: components['schemas']['Payloads'];
      /** @description The workflow-author-defined identifier of the query. Typically a function name. */
      readonly queryType?: string;
    };
    /** @description WorkflowRule describes a rule that can be applied to any workflow in this namespace. */
    readonly WorkflowRule: {
      /**
       * Format: date-time
       * @description Rule creation time.
       */
      readonly createTime?: string;
      /** @description Rule specification */
      readonly spec?: components['schemas']['WorkflowRuleSpec'];
    };
    readonly WorkflowRuleAction: {
      readonly activityPause?: components['schemas']['WorkflowRuleAction_ActionActivityPause'];
    };
    readonly WorkflowRuleAction_ActionActivityPause: Record<string, unknown>;
    readonly WorkflowRuleSpec: {
      /** @description WorkflowRuleAction to be taken when the rule is triggered and predicate is matched. */
      readonly actions?: readonly components['schemas']['WorkflowRuleAction'][];
      readonly activityStart?: components['schemas']['WorkflowRuleSpec_ActivityStartingTrigger'];
      /**
       * Format: date-time
       * @description Expiration time of the rule. After this time, the rule will be deleted.
       *  Can be empty if the rule should never expire.
       */
      readonly expirationTime?: string;
      /**
       * @description The id of the new workflow rule. Must be unique within the namespace.
       *  Can be set by the user, and can have business meaning.
       */
      readonly id?: string;
      /**
       * @description Restricted Visibility query.
       *  This query is used to filter workflows in this namespace to which this rule should apply.
       *  It is applied to any running workflow each time a triggering event occurs, before the trigger predicate is evaluated.
       *  The following workflow attributes are supported:
       *  - WorkflowType
       *  - WorkflowId
       *  - StartTime
       *  - ExecutionStatus
       */
      readonly visibilityQuery?: string;
    };
    /** @description Activity trigger will be triggered when an activity is about to start. */
    readonly WorkflowRuleSpec_ActivityStartingTrigger: {
      /**
       * @description Activity predicate is a SQL-like string filter parameter.
       *  It is used to match against workflow data.
       *  The following activity attributes are supported as part of the predicate:
       *  - ActivityType: An Activity Type is the mapping of a name to an Activity Definition..
       *  - ActivityId: The ID of the activity.
       *  - ActivityAttempt: The number attempts of the activity.
       *  - BackoffInterval: The current amount of time between scheduled attempts of the activity.
       *  - ActivityStatus: The status of the activity. Can be one of "Scheduled", "Started", "Paused".
       *  - TaskQueue: The name of the task queue the workflow specified that the activity should run on.
       *  Activity predicate support the following operators:
       *   * =, !=, >, >=, <, <=
       *   * AND, OR, ()
       *   * BETWEEN ... AND
       *     STARTS_WITH
       */
      readonly predicate?: string;
    };
    readonly WorkflowTaskCompletedEventAttributes: {
      /** @description Binary ID of the worker who completed this task */
      readonly binaryChecksum?: string;
      /**
       * @description The deployment that completed this task. May or may not be set for unversioned workers,
       *  depending on whether a value is sent by the SDK. This value updates workflow execution's
       *  `versioning_info.deployment`.
       *  Deprecated. Replaced with `worker_deployment_version`.
       */
      readonly deployment?: components['schemas']['Deployment'];
      /** @description Identity of the worker who completed this task */
      readonly identity?: string;
      /** @description Local usage data sent during workflow task completion and recorded here for posterity */
      readonly meteringMetadata?: components['schemas']['MeteringMetadata'];
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      readonly scheduledEventId?: string;
      /**
       * @description Data the SDK wishes to record for itself, but server need not interpret, and does not
       *  directly impact workflow state.
       */
      readonly sdkMetadata?: components['schemas']['WorkflowTaskCompletedMetadata'];
      /** @description The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to */
      readonly startedEventId?: string;
      /**
       * Format: enum
       * @description Versioning behavior sent by the worker that completed this task for this particular workflow
       *  execution. UNSPECIFIED means the task was completed by an unversioned worker. This value
       *  updates workflow execution's `versioning_info.behavior`.
       * @enum {string}
       */
      readonly versioningBehavior?:
        | 'VERSIONING_BEHAVIOR_UNSPECIFIED'
        | 'VERSIONING_BEHAVIOR_PINNED'
        | 'VERSIONING_BEHAVIOR_AUTO_UPGRADE';
      /**
       * @description The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`
       *  is set. This value updates workflow execution's `worker_deployment_name`.
       *  Experimental. Worker Deployments are experimental and might significantly change in the future.
       */
      readonly workerDeploymentName?: string;
      /**
       * @description The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
       *  is set. This value updates workflow execution's `versioning_info.version`.
       *  Experimental. Worker Deployments are experimental and might significantly change in the future.
       */
      readonly workerDeploymentVersion?: string;
      /**
       * @description Version info of the worker who processed this workflow task. If present, the `build_id` field
       *  within is also used as `binary_checksum`, which may be omitted in that case (it may also be
       *  populated to preserve compatibility).
       *  Deprecated. Use `deployment` and `versioning_behavior` instead.
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly WorkflowTaskCompletedMetadata: {
      /**
       * @description Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
       *
       *  During replay:
       *  * If a flag is not recognized (value is too high or not defined), it must fail the workflow
       *    task.
       *  * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
       *    that flag during and after this WFT are allowed to assume that the flag is present.
       *  * If a code check for a flag does not find the flag in the set of used flags, it must take
       *    the branch corresponding to the absence of that flag.
       *
       *  During non-replay execution of new WFTs:
       *  * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
       *    previously recorded) flags when completing the WFT.
       *
       *  SDKs which are too old to even know about this field at all are considered to produce
       *  undefined behavior if they replay workflows which used this mechanism.
       *
       *  (-- api-linter: core::0141::forbidden-types=disabled
       *      aip.dev/not-precedent: These really shouldn't have negative values. --)
       */
      readonly coreUsedFlags?: readonly number[];
      /**
       * @description Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
       *  here as processing a workflow with a different language than the one which authored it is
       *  already undefined behavior. See `core_used_patches` for more.
       *
       *  (-- api-linter: core::0141::forbidden-types=disabled
       *      aip.dev/not-precedent: These really shouldn't have negative values. --)
       */
      readonly langUsedFlags?: readonly number[];
      /**
       * @description Name of the SDK that processed the task. This is usually something like "temporal-go" and is
       *  usually the same as client-name gRPC header. This should only be set if its value changed
       *  since the last time recorded on the workflow (or be set on the first task).
       *
       *  (-- api-linter: core::0122::name-suffix=disabled
       *      aip.dev/not-precedent: We're ok with a name suffix here. --)
       */
      readonly sdkName?: string;
      /**
       * @description Version of the SDK that processed the task. This is usually something like "1.20.0" and is
       *  usually the same as client-version gRPC header. This should only be set if its value changed
       *  since the last time recorded on the workflow (or be set on the first task).
       */
      readonly sdkVersion?: string;
    };
    readonly WorkflowTaskFailedEventAttributes: {
      /** @description The original run id of the workflow. For reset workflow. */
      readonly baseRunId?: string;
      /**
       * @description DEPRECATED since 1.21 - use `worker_version` instead.
       *  If a worker explicitly failed this task, its binary id
       */
      readonly binaryChecksum?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly cause?:
        | 'WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID'
        | 'WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND'
        | 'WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY'
        | 'WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED';
      /** @description The failure details */
      readonly failure?: components['schemas']['Failure'];
      /** @description TODO: ? */
      readonly forkEventVersion?: string;
      /** @description If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task? */
      readonly identity?: string;
      /** @description If the workflow is being reset, the new run id. */
      readonly newRunId?: string;
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      readonly scheduledEventId?: string;
      /** @description The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to */
      readonly startedEventId?: string;
      /**
       * @description Version info of the worker who processed this workflow task. If present, the `build_id` field
       *  within is also used as `binary_checksum`, which may be omitted in that case (it may also be
       *  populated to preserve compatibility).
       *  Deprecated. Use the info inside the corresponding WorkflowTaskStartedEvent
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly WorkflowTaskScheduledEventAttributes: {
      /**
       * Format: int32
       * @description Starting at 1, how many attempts there have been to complete this task
       */
      readonly attempt?: number;
      /**
       * @description How long the worker has to process this task once receiving it before it times out
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      readonly startToCloseTimeout?: string;
      /** @description The task queue this workflow task was enqueued in, which could be a normal or sticky queue */
      readonly taskQueue?: components['schemas']['TaskQueue'];
    };
    readonly WorkflowTaskStartedEventAttributes: {
      /**
       * @description Used by server internally to properly reapply build ID redirects to an execution
       *  when rebuilding it from events.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly buildIdRedirectCounter?: string;
      /**
       * @description Total history size in bytes, which the workflow might use to decide when to
       *  continue-as-new regardless of the suggestion. Note that history event count is
       *  just the event id of this event, so we don't include it explicitly here.
       */
      readonly historySizeBytes?: string;
      /** @description Identity of the worker who picked up this task */
      readonly identity?: string;
      /** @description TODO: ? Appears unused? */
      readonly requestId?: string;
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      readonly scheduledEventId?: string;
      /**
       * @description True if this workflow should continue-as-new soon because its history size (in
       *  either event count or bytes) is getting large.
       */
      readonly suggestContinueAsNew?: boolean;
      /**
       * @description Version info of the worker to whom this task was dispatched.
       *  Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       */
      readonly workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    readonly WorkflowTaskTimedOutEventAttributes: {
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      readonly scheduledEventId?: string;
      /** @description The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to */
      readonly startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      readonly timeoutType?:
        | 'TIMEOUT_TYPE_UNSPECIFIED'
        | 'TIMEOUT_TYPE_START_TO_CLOSE'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_START'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_CLOSE'
        | 'TIMEOUT_TYPE_HEARTBEAT';
    };
    /**
     * @description Represents the identifier used by a workflow author to define the workflow. Typically, the
     *  name of a function. This is sometimes referred to as the workflow's "name"
     */
    readonly WorkflowType: {
      readonly name?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /** @description GetClusterInfo returns information about temporal cluster */
  GetClusterInfo: {
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetClusterInfoResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListNamespaces returns the information and configuration for all namespaces. */
  ListNamespaces: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /**
         * @description By default namespaces in NAMESPACE_STATE_DELETED state are not included.
         *  Setting include_deleted to true will include deleted namespaces.
         *  Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
         */
        'namespaceFilter.includeDeleted'?: boolean;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListNamespacesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RegisterNamespace creates a new namespace which can be used as a container for all resources.
   *
   *  A Namespace is a top level entity within Temporal, and is used as a container for resources
   *  like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
   *  isolation for all resources within the namespace. All resources belongs to exactly one
   *  namespace.
   */
  RegisterNamespace: {
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RegisterNamespaceRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RegisterNamespaceResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description DescribeNamespace returns the information and configuration for a registered namespace. */
  DescribeNamespace: {
    parameters: {
      query?: {
        id?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeNamespaceResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
   *
   *  This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
   *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
   *  no longer valid due to activity timeout, already being completed, or never having existed.
   */
  RespondActivityTaskCanceled: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RespondActivityTaskCanceledRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RespondActivityTaskCanceledResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskCanceled`. This version allows clients to record failures by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RespondActivityTaskCanceledById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RespondActivityTaskCanceledByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RespondActivityTaskCanceledByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RespondActivityTaskCompleted is called by workers when they successfully complete an activity
   *  task.
   *
   *  This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
   *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
   *  no longer valid due to activity timeout, already being completed, or never having existed.
   */
  RespondActivityTaskCompleted: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RespondActivityTaskCompletedRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RespondActivityTaskCompletedResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskCompleted`. This version allows clients to record completions by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RespondActivityTaskCompletedById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RespondActivityTaskCompletedByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RespondActivityTaskCompletedByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
   *
   *  This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
   *  a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
   *  longer valid due to activity timeout, already being completed, or never having existed.
   */
  RespondActivityTaskFailed: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RespondActivityTaskFailedRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RespondActivityTaskFailedResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskFailed`. This version allows clients to record failures by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RespondActivityTaskFailedById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RespondActivityTaskFailedByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RespondActivityTaskFailedByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
   *
   *  If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
   *  then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
   *  the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
   *  such situations, in that event, the SDK should request cancellation of the activity.
   */
  RecordActivityTaskHeartbeat: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RecordActivityTaskHeartbeatRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RecordActivityTaskHeartbeatResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RecordActivityTaskHeartbeatById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RecordActivityTaskHeartbeatByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RecordActivityTaskHeartbeatByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description PauseActivity pauses the execution of an activity specified by its ID or type.
   *  If there are multiple pending activities of the provided type - all of them will be paused
   *
   *  Pausing an activity means:
   *  - If the activity is currently waiting for a retry or is running and subsequently fails,
   *    it will not be rescheduled until it is unpaused.
   *  - If the activity is already paused, calling this method will have no effect.
   *  - If the activity is running and finishes successfully, the activity will be completed.
   *  - If the activity is running and finishes with failure:
   *    * if there is no retry left - the activity will be completed.
   *    * if there are more retries left - the activity will be paused.
   *  For long-running activities:
   *  - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
   *  - The activity should respond to the cancellation accordingly.
   *
   *  Returns a `NotFound` error if there is no pending activity with the provided ID or type
   */
  PauseActivity: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['PauseActivityRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['PauseActivityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description ResetActivity resets the execution of an activity specified by its ID or type.
   *  If there are multiple pending activities of the provided type - all of them will be reset.
   *
   *  Resetting an activity means:
   *  * number of attempts will be reset to 0.
   *  * activity timeouts will be reset.
   *  * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
   *     it will be scheduled immediately (* see 'jitter' flag),
   *
   *  Flags:
   *
   *  'jitter': the activity will be scheduled at a random time within the jitter duration.
   *  If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
   *  'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
   *  'keep_paused': if the activity is paused, it will remain paused.
   *
   *  Returns a `NotFound` error if there is no pending activity with the provided ID or type.
   */
  ResetActivity: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['ResetActivityRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ResetActivityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description UnpauseActivity unpauses the execution of an activity specified by its ID or type.
   *  If there are multiple pending activities of the provided type - all of them will be unpaused.
   *
   *  If activity is not paused, this call will have no effect.
   *  If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
   *  Once the activity is unpaused, all timeout timers will be regenerated.
   *
   *  Flags:
   *  'jitter': the activity will be scheduled at a random time within the jitter duration.
   *  'reset_attempts': the number of attempts will be reset.
   *  'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
   *
   *  Returns a `NotFound` error if there is no pending activity with the provided ID or type
   */
  UnpauseActivity: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UnpauseActivityRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UnpauseActivityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
   *  If there are multiple pending activities of the provided type - all of them will be updated.
   */
  UpdateActivityOptions: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateActivityOptionsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateActivityOptionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
  ListArchivedWorkflowExecutions: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListArchivedWorkflowExecutionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListBatchOperations returns a list of batch operations */
  ListBatchOperations: {
    parameters: {
      query?: {
        /** @description List page size */
        pageSize?: number;
        /** @description Next page token */
        nextPageToken?: string;
      };
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListBatchOperationsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description DescribeBatchOperation returns the information about a batch operation */
  DescribeBatchOperation: {
    parameters: {
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeBatchOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description StartBatchOperation starts a new batch operation */
  StartBatchOperation: {
    parameters: {
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Job ID defines the unique ID for the batch job */
        jobId: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['StartBatchOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['StartBatchOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description StopBatchOperation stops a batch operation */
  StopBatchOperation: {
    parameters: {
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['StopBatchOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['StopBatchOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Sets a deployment as the current deployment for its deployment series. Can optionally update
   *  the metadata of the deployment as well.
   *  Experimental. This API might significantly change or be removed in a future release.
   *  Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
   */
  SetCurrentDeployment: {
    parameters: {
      path: {
        namespace: string;
        'deployment.series_name': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['SetCurrentDeploymentRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['SetCurrentDeploymentResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Returns the current deployment (and its info) for a given deployment series.
   *  Experimental. This API might significantly change or be removed in a future release.
   *  Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
   */
  GetCurrentDeployment: {
    parameters: {
      path: {
        namespace: string;
        seriesName: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetCurrentDeploymentResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Lists worker deployments in the namespace. Optionally can filter based on deployment series
   *  name.
   *  Experimental. This API might significantly change or be removed in a future release.
   *  Deprecated. Replaced with `ListWorkerDeployments`.
   */
  ListDeployments: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description Optional. Use to filter based on exact series name match. */
        seriesName?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListDeploymentsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Describes a worker deployment.
   *  Experimental. This API might significantly change or be removed in a future release.
   *  Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
   */
  DescribeDeployment: {
    parameters: {
      query?: {
        /**
         * @description Different versions of the same worker service/application are related together by having a
         *  shared series name.
         *  Out of all deployments of a series, one can be designated as the current deployment, which
         *  receives new workflow executions and new tasks of workflows with
         *  `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.
         */
        'deployment.seriesName'?: string;
        /**
         * @description Build ID changes with each version of the worker when the worker program code and/or config
         *  changes.
         */
        'deployment.buildId'?: string;
      };
      path: {
        namespace: string;
        'deployment.series_name': string;
        'deployment.build_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeDeploymentResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Returns the reachability level of a worker deployment to help users decide when it is time
   *  to decommission a deployment. Reachability level is calculated based on the deployment's
   *  `status` and existing workflows that depend on the given deployment for their execution.
   *  Calculating reachability is relatively expensive. Therefore, server might return a recently
   *  cached value. In such a case, the `last_update_time` will inform you about the actual
   *  reachability calculation time.
   *  Experimental. This API might significantly change or be removed in a future release.
   *  Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
   */
  GetDeploymentReachability: {
    parameters: {
      query?: {
        /**
         * @description Different versions of the same worker service/application are related together by having a
         *  shared series name.
         *  Out of all deployments of a series, one can be designated as the current deployment, which
         *  receives new workflow executions and new tasks of workflows with
         *  `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.
         */
        'deployment.seriesName'?: string;
        /**
         * @description Build ID changes with each version of the worker when the worker program code and/or config
         *  changes.
         */
        'deployment.buildId'?: string;
      };
      path: {
        namespace: string;
        'deployment.series_name': string;
        'deployment.build_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetDeploymentReachabilityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description List all schedules in a namespace. */
  ListSchedules: {
    parameters: {
      query?: {
        /** @description How many to return at once. */
        maximumPageSize?: number;
        /** @description Token to get the next page of results. */
        nextPageToken?: string;
        /** @description Query to filter schedules. */
        query?: string;
      };
      path: {
        /** @description The namespace to list schedules in. */
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListSchedulesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Returns the schedule description and current state of an existing schedule. */
  DescribeSchedule: {
    parameters: {
      path: {
        /** @description The namespace of the schedule to describe. */
        namespace: string;
        /** @description The id of the schedule to describe. */
        scheduleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Creates a new schedule. */
  CreateSchedule: {
    parameters: {
      path: {
        /** @description The namespace the schedule should be created in. */
        namespace: string;
        /** @description The id of the new schedule. */
        scheduleId: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['CreateScheduleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['CreateScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Deletes a schedule, removing it from the system. */
  DeleteSchedule: {
    parameters: {
      query?: {
        /** @description The identity of the client who initiated this request. */
        identity?: string;
      };
      path: {
        /** @description The namespace of the schedule to delete. */
        namespace: string;
        /** @description The id of the schedule to delete. */
        scheduleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DeleteScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Lists matching times within a range. */
  ListScheduleMatchingTimes: {
    parameters: {
      query?: {
        /** @description Time range to query. */
        startTime?: string;
        endTime?: string;
      };
      path: {
        /** @description The namespace of the schedule to query. */
        namespace: string;
        /** @description The id of the schedule to query. */
        scheduleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListScheduleMatchingTimesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Makes a specific change to a schedule or triggers an immediate action. */
  PatchSchedule: {
    parameters: {
      path: {
        /** @description The namespace of the schedule to patch. */
        namespace: string;
        /** @description The id of the schedule to patch. */
        scheduleId: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['PatchScheduleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['PatchScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Changes the configuration or state of an existing schedule. */
  UpdateSchedule: {
    parameters: {
      path: {
        /** @description The namespace of the schedule to update. */
        namespace: string;
        /** @description The id of the schedule to update. */
        scheduleId: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateScheduleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListSearchAttributes returns comprehensive information about search attributes. */
  ListSearchAttributes: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListSearchAttributesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
   *    - List of pollers
   *    - Workflow Reachability status
   *    - Backlog info for Workflow and/or Activity tasks
   */
  DescribeTaskQueue: {
    parameters: {
      query?: {
        'taskQueue.name'?: string;
        /** @description Default: TASK_QUEUE_KIND_NORMAL. */
        'taskQueue.kind'?:
          | 'TASK_QUEUE_KIND_UNSPECIFIED'
          | 'TASK_QUEUE_KIND_NORMAL'
          | 'TASK_QUEUE_KIND_STICKY';
        /**
         * @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
         *  the normal task queue that the sticky worker is running on.
         */
        'taskQueue.normalName'?: string;
        /**
         * @description Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.
         *  If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
         */
        taskQueueType?:
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS';
        /** @description Deprecated. Ignored in `ENHANCED` mode. */
        includeTaskQueueStatus?: boolean;
        /** @description All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode. */
        apiMode?:
          | 'DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED'
          | 'DESCRIBE_TASK_QUEUE_MODE_ENHANCED';
        /** @description Include specific Build IDs. */
        'versions.buildIds'?: readonly string[];
        /** @description Include the unversioned queue. */
        'versions.unversioned'?: boolean;
        /**
         * @description Include all active versions. A version is considered active if, in the last few minutes,
         *  it has had new tasks or polls, or it has been the subject of certain task queue API calls.
         */
        'versions.allActive'?: boolean;
        /** @description Task queue types to report info about. If not specified, all types are considered. */
        taskQueueTypes?: readonly (
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS'
        )[];
        /** @description Report stats for the requested task queue types and versions */
        reportStats?: boolean;
        /** @description Report list of pollers for requested task queue types and versions */
        reportPollers?: boolean;
        /**
         * @description Report task reachability for the requested versions and all task types (task reachability is not reported
         *  per task type).
         */
        reportTaskReachability?: boolean;
      };
      path: {
        namespace: string;
        'task_queue.name': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeTaskQueueResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Deprecated. Use `GetWorkerVersioningRules`.
   *  Fetches the worker build id versioning sets for a task queue.
   */
  GetWorkerBuildIdCompatibility: {
    parameters: {
      query?: {
        /**
         * @description Limits how many compatible sets will be returned. Specify 1 to only return the current
         *  default major version set. 0 returns all sets.
         */
        maxSets?: number;
      };
      path: {
        namespace: string;
        /** @description Must be set, the task queue to interrogate about worker id compatibility. */
        taskQueue: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetWorkerBuildIdCompatibilityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Fetches the Build ID assignment and redirect rules for a Task Queue.
   *  WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
   */
  GetWorkerVersioningRules: {
    parameters: {
      path: {
        namespace: string;
        taskQueue: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetWorkerVersioningRulesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description UpdateNamespace is used to update the information and configuration of a registered
   *  namespace.
   */
  UpdateNamespace: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateNamespaceRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateNamespaceResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Describes a worker deployment version.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  DescribeWorkerDeploymentVersion: {
    parameters: {
      path: {
        namespace: string;
        /** @description Deployment Version identifier in the form "<deployment_name>.<build_id>". */
        version: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeWorkerDeploymentVersionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Used for manual deletion of Versions. User can delete a Version only when all the
   *  following conditions are met:
   *   - It is not the Current or Ramping Version of its Deployment.
   *   - It has no active pollers (none of the task queues in the Version have pollers)
   *   - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
   *     can be skipped by passing `skip-drainage=true`.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  DeleteWorkerDeploymentVersion: {
    parameters: {
      query?: {
        /**
         * @description Pass to force deletion even if the Version is draining. In this case the open pinned
         *  workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.
         */
        skipDrainage?: boolean;
        /** @description Optional. The identity of the client who initiated this request. */
        identity?: string;
      };
      path: {
        namespace: string;
        /** @description Deployment Version identifier in the form "<deployment_name>.<build_id>". */
        version: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DeleteWorkerDeploymentVersionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Updates the user-given metadata attached to a Worker Deployment Version.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  UpdateWorkerDeploymentVersionMetadata: {
    parameters: {
      path: {
        namespace: string;
        /** @description Deployment Version identifier in the form "<deployment_name>.<build_id>". */
        version: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateWorkerDeploymentVersionMetadataRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateWorkerDeploymentVersionMetadataResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Lists all Worker Deployments that are tracked in the Namespace.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  ListWorkerDeployments: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListWorkerDeploymentsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Describes a Worker Deployment.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  DescribeWorkerDeployment: {
    parameters: {
      path: {
        namespace: string;
        deploymentName: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeWorkerDeploymentResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Deletes records of (an old) Deployment. A deployment can only be deleted if
   *  it has no Version in it.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  DeleteWorkerDeployment: {
    parameters: {
      query?: {
        /** @description Optional. The identity of the client who initiated this request. */
        identity?: string;
      };
      path: {
        namespace: string;
        deploymentName: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DeleteWorkerDeploymentResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
   *  Version if it is the Version being set as Current.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  SetWorkerDeploymentCurrentVersion: {
    parameters: {
      path: {
        namespace: string;
        deploymentName: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['SetWorkerDeploymentCurrentVersionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['SetWorkerDeploymentCurrentVersionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
   *  gradual ramp to unversioned workers too.
   *  Experimental. This API might significantly change or be removed in a future release.
   */
  SetWorkerDeploymentRampingVersion: {
    parameters: {
      path: {
        namespace: string;
        deploymentName: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['SetWorkerDeploymentRampingVersionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['SetWorkerDeploymentRampingVersionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Deprecated. Use `DescribeTaskQueue`.
   *
   *  Fetches task reachability to determine whether a worker may be retired.
   *  The request may specify task queues to query for or let the server fetch all task queues mapped to the given
   *  build IDs.
   *
   *  When requesting a large number of task queues or all task queues associated with the given build ids in a
   *  namespace, all task queues will be listed in the response but some of them may not contain reachability
   *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
   *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
   *  another call to get the reachability for those task queues.
   *
   *  Open source users can adjust this limit by setting the server's dynamic config value for
   *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
   */
  GetWorkerTaskReachability: {
    parameters: {
      query?: {
        /**
         * @description Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
         *  The number of build ids that can be queried in a single API call is limited.
         *  Open source users can adjust this limit by setting the server's dynamic config value for
         *  `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
         */
        buildIds?: readonly string[];
        /**
         * @description Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
         *  build ids in the namespace.
         *  Must specify at least one task queue if querying for an unversioned worker.
         *  The number of task queues that the server will fetch reachability information for is limited.
         *  See the `GetWorkerTaskReachabilityResponse` documentation for more information.
         */
        taskQueues?: readonly string[];
        /**
         * @description Type of reachability to query for.
         *  `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
         *  Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
         *  Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
         *  unspecified.
         *  See the TaskReachability docstring for information about each enum variant.
         */
        reachability?:
          | 'TASK_REACHABILITY_UNSPECIFIED'
          | 'TASK_REACHABILITY_NEW_WORKFLOWS'
          | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
          | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
          | 'TASK_REACHABILITY_CLOSED_WORKFLOWS';
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetWorkerTaskReachabilityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
  CountWorkflowExecutions: {
    parameters: {
      query?: {
        query?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['CountWorkflowExecutionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Return all namespace workflow rules */
  ListWorkflowRules: {
    parameters: {
      query?: {
        nextPageToken?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListWorkflowRulesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Create a new workflow rule. The rules are used to control the workflow execution.
   *  The rule will be applied to all running and new workflows in the namespace.
   *  If the rule with such ID already exist this call will fail
   *  Note: the rules are part of namespace configuration and will be stored in the namespace config.
   *  Namespace config is eventually consistent.
   */
  CreateWorkflowRule: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['CreateWorkflowRuleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['CreateWorkflowRuleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description DescribeWorkflowRule return the rule specification for existing rule id.
   *  If there is no rule with such id - NOT FOUND error will be returned.
   */
  DescribeWorkflowRule: {
    parameters: {
      path: {
        namespace: string;
        /** @description User-specified ID of the rule to read. Unique within the namespace. */
        ruleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeWorkflowRuleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Delete rule by rule id */
  DeleteWorkflowRule: {
    parameters: {
      path: {
        namespace: string;
        /** @description ID of the rule to delete. Unique within the namespace. */
        ruleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DeleteWorkflowRuleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
  ListWorkflowExecutions: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListWorkflowExecutionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description DescribeWorkflowExecution returns information about the specified workflow execution. */
  DescribeWorkflowExecution: {
    parameters: {
      query?: {
        'execution.workflowId'?: string;
        'execution.runId'?: string;
      };
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DescribeWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
   *  `NotFound` if the specified workflow execution is unknown to the service.
   */
  GetWorkflowExecutionHistory: {
    parameters: {
      query?: {
        'execution.workflowId'?: string;
        'execution.runId'?: string;
        maximumPageSize?: number;
        /**
         * @description If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
         *  these, it should be passed here to fetch the next page.
         */
        nextPageToken?: string;
        /**
         * @description If set to true, the RPC call will not resolve until there is a new event which matches
         *  the `history_event_filter_type`, or a timeout is hit.
         */
        waitNewEvent?: boolean;
        /**
         * @description Filter returned events such that they match the specified filter type.
         *  Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
         */
        historyEventFilterType?:
          | 'HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED'
          | 'HISTORY_EVENT_FILTER_TYPE_ALL_EVENT'
          | 'HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT';
        skipArchival?: boolean;
      };
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetWorkflowExecutionHistoryResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
   *  order (starting from last event). Fails with`NotFound` if the specified workflow execution is
   *  unknown to the service.
   */
  GetWorkflowExecutionHistoryReverse: {
    parameters: {
      query?: {
        'execution.workflowId'?: string;
        'execution.runId'?: string;
        maximumPageSize?: number;
        nextPageToken?: string;
      };
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetWorkflowExecutionHistoryReverseResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description QueryWorkflow requests a query be executed for a specified workflow execution. */
  QueryWorkflow: {
    parameters: {
      path: {
        namespace: string;
        'execution.workflow_id': string;
        'query.query_type': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['QueryWorkflowRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['QueryWorkflowResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description TriggerWorkflowRule allows to:
   *   * trigger existing rule for a specific workflow execution;
   *   * trigger rule for a specific workflow execution without creating a rule;
   *  This is useful for one-off operations.
   */
  TriggerWorkflowRule: {
    parameters: {
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['TriggerWorkflowRuleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['TriggerWorkflowRuleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
   *  a workflow execution.
   *
   *  This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
   *  workflow history and a new workflow task created for the workflow. It returns success if the requested
   *  workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
   */
  RequestCancelWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['RequestCancelWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['RequestCancelWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description ResetWorkflowExecution will reset an existing workflow execution to a specified
   *  `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
   *  execution instance.
   *  TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
   */
  ResetWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['ResetWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ResetWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description SignalWorkflowExecution is used to send a signal to a running workflow execution.
   *
   *  This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
   *  task being created for the execution.
   */
  SignalWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['SignalWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['SignalWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description TerminateWorkflowExecution terminates an existing workflow execution by recording a
   *  `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
   *  execution instance.
   */
  TerminateWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['TerminateWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['TerminateWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution. */
  UpdateWorkflowExecutionOptions: {
    parameters: {
      path: {
        /** @description The namespace name of the target Workflow. */
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateWorkflowExecutionOptionsRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateWorkflowExecutionOptionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Invokes the specified Update function on user Workflow code. */
  UpdateWorkflowExecution: {
    parameters: {
      path: {
        /** @description The namespace name of the target Workflow. */
        namespace: string;
        'workflow_execution.workflow_id': string;
        'request.input.name': string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description StartWorkflowExecution starts a new workflow execution.
   *
   *  It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
   *  also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
   *  instance already exists with same workflow id.
   */
  StartWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        workflowId: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['StartWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['StartWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
   *  it isn't yet started.
   *
   *  If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
   *  and a workflow task is generated.
   *
   *  If the workflow is not running or not found, then the workflow is created with
   *  `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
   *  workflow task is generated.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "With" is used to indicate combined operation. --)
   */
  SignalWithStartWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        workflowId: string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['SignalWithStartWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['SignalWithStartWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description ExecuteMultiOperation executes multiple operations within a single workflow.
   *
   *  Operations are started atomically, meaning if *any* operation fails to be started, none are,
   *  and the request fails. Upon start, the API returns only when *all* operations have a response.
   *
   *  Upon failure, it returns `MultiOperationExecutionFailure` where the status code
   *  equals the status code of the *first* operation that failed to be started.
   *
   *  NOTE: Experimental API.
   */
  ExecuteMultiOperation: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['ExecuteMultiOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ExecuteMultiOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
   *  next_page_token field of the previous response to get the next page of results. An empty next_page_token
   *  indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
   *  earlier than the previous page's last endpoint's ID may be missed.
   */
  ListNexusEndpoints: {
    parameters: {
      query?: {
        pageSize?: number;
        /**
         * @description To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's
         *  response, the token will be empty if there's no other page.
         *  Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size.
         */
        nextPageToken?: string;
        /**
         * @description Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.
         *  (-- api-linter: core::203::field-behavior-required=disabled
         *      aip.dev/not-precedent: Not following linter rules. --)
         */
        name?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['ListNexusEndpointsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
   *  ALREADY_EXISTS.
   *  Returns the created endpoint with its initial version. You may use this version for subsequent updates.
   */
  CreateNexusEndpoint: {
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['CreateNexusEndpointRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['CreateNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
  GetNexusEndpoint: {
    parameters: {
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Delete an incoming Nexus service by ID. */
  DeleteNexusEndpoint: {
    parameters: {
      query?: {
        /** @description Data version for this endpoint. Must match current version. */
        version?: string;
      };
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['DeleteNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
   *  `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
   *  match.
   *  Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
   *  need to increment the version yourself. The server will increment the version for you after each update.
   */
  UpdateNexusEndpoint: {
    parameters: {
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
    };
    readonly requestBody: {
      readonly content: {
        readonly 'application/json': components['schemas']['UpdateNexusEndpointRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['UpdateNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description GetSystemInfo returns information about the system. */
  GetSystemInfo: {
    responses: {
      /** @description OK */
      200: {
        content: {
          readonly 'application/json': components['schemas']['GetSystemInfoResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          readonly 'application/json': components['schemas']['Status'];
        };
      };
    };
  };
}
